<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mscdex/ssh2-streams#readme">ssh2-streams (v0.1.16)</a>
</h1>
<h4>SSH2 and SFTP(v3) client/server protocol streams for node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams">module ssh2-streams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream
            <span class="apidocSignatureSpan">(cfg, remoteIdentRaw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream.Stats
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>SSH2Stream
            <span class="apidocSignatureSpan">(cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>jsbn
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream.Stats.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>SSH2Stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>jsbn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SFTPStream">module ssh2-streams.SFTPStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.SFTPStream">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream
            <span class="apidocSignatureSpan">(cfg, remoteIdentRaw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>Stats
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.flagsToString">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>flagsToString
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.stringToFlags">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>stringToFlags
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.super_">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>OPEN_MODE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>STATUS_CODE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SFTPStream.Stats">module ssh2-streams.SFTPStream.Stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.Stats">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>Stats
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SFTPStream.Stats.prototype">module ssh2-streams.SFTPStream.Stats.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype._checkModeProperty">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>_checkModeProperty
            <span class="apidocSignatureSpan">(property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isBlockDevice">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isBlockDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isCharacterDevice">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isCharacterDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isDirectory">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFIFO">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isFIFO
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFile">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSocket">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSymbolicLink">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isSymbolicLink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SFTPStream.prototype">module ssh2-streams.SFTPStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.__push">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>__push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.__read">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>__read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype._cleanup">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_cleanup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype._read">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype._transform">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.appendFile">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>appendFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.attrs">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>attrs
            <span class="apidocSignatureSpan">(id, attrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.chmod">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>chmod
            <span class="apidocSignatureSpan">(path, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.chown">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>chown
            <span class="apidocSignatureSpan">(path, uid, gid, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.close">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>close
            <span class="apidocSignatureSpan">(handle, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.createReadStream">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.createWriteStream">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.data">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>data
            <span class="apidocSignatureSpan">(id, data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.exists">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>exists
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fstatvfs">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_fstatvfs
            <span class="apidocSignatureSpan">(handle, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fsync">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_fsync
            <span class="apidocSignatureSpan">(handle, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_hardlink">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_hardlink
            <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_rename">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_rename
            <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_statvfs">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_statvfs
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fastGet">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fastGet
            <span class="apidocSignatureSpan">(remotePath, localPath, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fastPut">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fastPut
            <span class="apidocSignatureSpan">(localPath, remotePath, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fchmod">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fchmod
            <span class="apidocSignatureSpan">(handle, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fchown">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fchown
            <span class="apidocSignatureSpan">(handle, uid, gid, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fsetstat">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fsetstat
            <span class="apidocSignatureSpan">(handle, attrs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fstat">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fstat
            <span class="apidocSignatureSpan">(handle, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.futimes">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>futimes
            <span class="apidocSignatureSpan">(handle, atime, mtime, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.handle">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>handle
            <span class="apidocSignatureSpan">(id, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.lstat">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>lstat
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.mkdir">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>mkdir
            <span class="apidocSignatureSpan">(path, attrs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.name">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>name
            <span class="apidocSignatureSpan">(id, names)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.open">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>open
            <span class="apidocSignatureSpan">(path, flags_, attrs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.opendir">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>opendir
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.push">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readData">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readData
            <span class="apidocSignatureSpan">(handle, buf, off, len, position, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readFile">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readFile
            <span class="apidocSignatureSpan">(path, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readdir">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readdir
            <span class="apidocSignatureSpan">(where, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readlink">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readlink
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.realpath">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>realpath
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.rename">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>rename
            <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.rmdir">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>rmdir
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.setstat">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>setstat
            <span class="apidocSignatureSpan">(path, attrs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.stat">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>stat
            <span class="apidocSignatureSpan">(path, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.status">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>status
            <span class="apidocSignatureSpan">(id, code, message, lang)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.symlink">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>symlink
            <span class="apidocSignatureSpan">(targetPath, linkPath, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.unlink">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>unlink
            <span class="apidocSignatureSpan">(filename, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.utimes">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>utimes
            <span class="apidocSignatureSpan">(path, atime, mtime, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.writeData">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>writeData
            <span class="apidocSignatureSpan">(handle, buf, off, len, position, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SFTPStream.prototype.writeFile">
            function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SSH2Stream">module ssh2-streams.SSH2Stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.SSH2Stream">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>SSH2Stream
            <span class="apidocSignatureSpan">(cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream._send">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.</span>_send
            <span class="apidocSignatureSpan">(self, payload, cb, bypass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.super_">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.SSH2Stream.prototype">module ssh2-streams.SSH2Stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.__push">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>__push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.__read">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>__read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._cleanup">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_cleanup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._read">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._transform">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback, decomp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authFailure">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authFailure
            <span class="apidocSignatureSpan">(authMethods, isPartial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authHostbased">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authHostbased
            <span class="apidocSignatureSpan">(username, pubKey, hostname, userlocal, cbSign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoReq">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authInfoReq
            <span class="apidocSignatureSpan">(name, instructions, prompts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoRes">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authInfoRes
            <span class="apidocSignatureSpan">(responses)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authKeyboard">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authKeyboard
            <span class="apidocSignatureSpan">(username)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authNone">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authNone
            <span class="apidocSignatureSpan">(username)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPK">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPK
            <span class="apidocSignatureSpan">(username, pubKey, cbSign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPKOK">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPKOK
            <span class="apidocSignatureSpan">(keyAlgo, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPasswdChg">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPasswdChg
            <span class="apidocSignatureSpan">(prompt, lang)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPassword">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPassword
            <span class="apidocSignatureSpan">(username, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authSuccess">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authSuccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.cancelTcpipForward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>cancelTcpipForward
            <span class="apidocSignatureSpan">(bindAddr, bindPort, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelClose">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelClose
            <span class="apidocSignatureSpan">(chan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelData">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelData
            <span class="apidocSignatureSpan">(chan, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelEOF">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelEOF
            <span class="apidocSignatureSpan">(chan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelExtData">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelExtData
            <span class="apidocSignatureSpan">(chan, data, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelFailure">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelFailure
            <span class="apidocSignatureSpan">(chan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenConfirm">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelOpenConfirm
            <span class="apidocSignatureSpan">(remoteChan, localChan, initWindow, maxPacket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenFail">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelOpenFail
            <span class="apidocSignatureSpan">(remoteChan, reason, desc, lang)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelSuccess">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelSuccess
            <span class="apidocSignatureSpan">(chan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelWindowAdjust">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelWindowAdjust
            <span class="apidocSignatureSpan">(chan, amount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.directTcpip">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>directTcpip
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.disconnect">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.env">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>env
            <span class="apidocSignatureSpan">(chan, key, val, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exec">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exec
            <span class="apidocSignatureSpan">(chan, cmd, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exitSignal">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exitSignal
            <span class="apidocSignatureSpan">(chan, name, coreDumped, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exitStatus">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exitStatus
            <span class="apidocSignatureSpan">(chan, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.forwardedTcpip">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>forwardedTcpip
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_agentForward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_agentForward
            <span class="apidocSignatureSpan">(chan, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_cancelStreamLocalForward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_cancelStreamLocalForward
            <span class="apidocSignatureSpan">(socketPath, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_directStreamLocal">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_directStreamLocal
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_forwardedStreamLocal">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_forwardedStreamLocal
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_noMoreSessions">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_noMoreSessions
            <span class="apidocSignatureSpan">(wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_streamLocalForward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_streamLocalForward
            <span class="apidocSignatureSpan">(socketPath, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.ping">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>ping
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.pty">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>pty
            <span class="apidocSignatureSpan">(chan, rows, cols, height, width, term, modes, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.push">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.rekey">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>rekey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.requestFailure">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>requestFailure
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.requestSuccess">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>requestSuccess
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.reset">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>reset
            <span class="apidocSignatureSpan">(noend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.service">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>service
            <span class="apidocSignatureSpan">(svcName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.serviceAccept">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>serviceAccept
            <span class="apidocSignatureSpan">(svcName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.session">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>session
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.shell">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>shell
            <span class="apidocSignatureSpan">(chan, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.signal">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>signal
            <span class="apidocSignatureSpan">(chan, signal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.subsystem">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>subsystem
            <span class="apidocSignatureSpan">(chan, name, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.tcpipForward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>tcpipForward
            <span class="apidocSignatureSpan">(bindAddr, bindPort, wantReply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.windowChange">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>windowChange
            <span class="apidocSignatureSpan">(chan, rows, cols, height, width)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.x11">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>x11
            <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.x11Forward">
            function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>x11Forward
            <span class="apidocSignatureSpan">(chan, cfg, wantReply)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.jsbn">module ssh2-streams.jsbn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.jsbn">
            function <span class="apidocSignatureSpan">ssh2-streams.</span>jsbn
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.jsbn.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ssh2-streams.jsbn.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.jsbn.prototype">module ssh2-streams.jsbn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.Barrett">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>Barrett
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.abs">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.add">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>add
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.addTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>addTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.am">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>am
            <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.and">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>and
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.andNot">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>andNot
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.bitCount">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.bitLength">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.bitwiseTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitwiseTo
            <span class="apidocSignatureSpan">(a, op, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.byteValue">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>byteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.changeBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>changeBit
            <span class="apidocSignatureSpan">(n, op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.chunkSize">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>chunkSize
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.clamp">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.clearBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clearBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.clone">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.compareTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>compareTo
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.copyTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>copyTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.dAddOffset">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dAddOffset
            <span class="apidocSignatureSpan">(n, w)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.dMultiply">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dMultiply
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.divRemTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divRemTo
            <span class="apidocSignatureSpan">(m, q, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.divide">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divide
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.divideAndRemainder">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divideAndRemainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.dlShiftTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dlShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.drShiftTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>drShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.equals">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>equals
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.exp">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>exp
            <span class="apidocSignatureSpan">(e, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.flipBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>flipBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.fromInt">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromInt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.fromNumber">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromNumber
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.fromRadix">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromRadix
            <span class="apidocSignatureSpan">(s, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.fromString">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromString
            <span class="apidocSignatureSpan">(s, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.gcd">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>gcd
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.getLowestSetBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>getLowestSetBit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.intValue">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>intValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.invDigit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>invDigit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.isEven">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.isProbablePrime">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>isProbablePrime
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.lShiftTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>lShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.max">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>max
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.millerRabin">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>millerRabin
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.min">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>min
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.mod">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>mod
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.modInt">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.modInverse">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modInverse
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.modPow">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modPow
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.modPowInt">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modPowInt
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.multiply">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiply
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyLowerTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyLowerTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyUpperTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyUpperTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.negate">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.not">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.or">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>or
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.pow">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>pow
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.rShiftTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>rShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.remainder">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>remainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.setBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>setBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.shiftRight">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.shortValue">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shortValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.signum">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>signum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.square">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>square
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.squareTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>squareTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.subTo">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>subTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.subtract">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>subtract
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.testBit">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>testBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.toByteArray">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toByteArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.toRadix">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toRadix
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.toString">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toString
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.jsbn.prototype.xor">
            function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>xor
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>DB</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>DM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>DV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>F1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>F2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>FV</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ssh2-streams.utils">module ssh2-streams.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.DSAKeySSHToASN1">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSAKeySSHToASN1
            <span class="apidocSignatureSpan">(key, self, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.DSASigBERToBare">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSASigBERToBare
            <span class="apidocSignatureSpan">(signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.DSASigBareToBER">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSASigBareToBER
            <span class="apidocSignatureSpan">(signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.ECDSAKeySSHToASN1">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSAKeySSHToASN1
            <span class="apidocSignatureSpan">(key, self, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.ECDSASigASN1ToSSH">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSASigASN1ToSSH
            <span class="apidocSignatureSpan">(signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.ECDSASigSSHToASN1">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSASigSSHToASN1
            <span class="apidocSignatureSpan">(signature, self, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.RSAKeySSHToASN1">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>RSAKeySSHToASN1
            <span class="apidocSignatureSpan">(key, self, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.convertPPKPrivate">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>convertPPKPrivate
            <span class="apidocSignatureSpan">(keyInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.decryptKey">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>decryptKey
            <span class="apidocSignatureSpan">(keyInfo, passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.genPublicKey">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>genPublicKey
            <span class="apidocSignatureSpan">(keyInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.isStreamCipher">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>isStreamCipher
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.iv_inc">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>iv_inc
            <span class="apidocSignatureSpan">(iv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.parseKey">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>parseKey
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.readInt">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>readInt
            <span class="apidocSignatureSpan">(buffer, start, stream, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.readString">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>readString
            <span class="apidocSignatureSpan">(buffer, start, encoding, stream, cb, maxLen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ssh2-streams.utils.verifyPPKMAC">
            function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>verifyPPKMAC
            <span class="apidocSignatureSpan">(keyInfo, passphrase, privateKey)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams" id="apidoc.module.ssh2-streams">module ssh2-streams</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream" id="apidoc.element.ssh2-streams.SFTPStream">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream
        <span class="apidocSignatureSpan">(cfg, remoteIdentRaw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SFTPStream(cfg, remoteIdentRaw) {
  if (typeof cfg === 'string' &amp;&amp; !remoteIdentRaw) {
    remoteIdentRaw = cfg;
    cfg = undefined;
  }
  if (typeof cfg !== 'object' || !cfg)
    cfg = {};

  TransformStream.call(this, {
    highWaterMark: (typeof cfg.highWaterMark === 'number'
                    ? cfg.highWaterMark
                    : 32 * 1024)
  });

  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);
  this.server = (cfg.server ? true : false);
  this._isOpenSSH = (remoteIdentRaw &amp;&amp; RE_OPENSSH.test(remoteIdentRaw));
  this._needContinue = false;
  this._state = {
    // common
    status: 'packet_header',
    writeReqid: -1,
    pktLeft: undefined,
    pktHdrBuf: new Buffer(9), // room for pktLen + pktType + req id
    pktBuf: undefined,
    pktType: undefined,
    version: undefined,
    extensions: {},

    // client
    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),
    requests: {}
  };

  var self = this;
  this.on('end', function() {
    self.readable = false;
  }).on('finish', onFinish)
    .on('prefinish', onFinish);
  function onFinish() {
    self.writable = false;
    self._cleanup(false);
  }

  if (!this.server)
    this.push(CLIENT_VERSION_BUFFER);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats" id="apidoc.element.ssh2-streams.SFTPStream.Stats">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream.Stats
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats(initial) {
  this.mode = (initial &amp;&amp; initial.mode);
  this.permissions = this.mode; // backwards compatiblity
  this.uid = (initial &amp;&amp; initial.uid);
  this.gid = (initial &amp;&amp; initial.gid);
  this.size = (initial &amp;&amp; initial.size);
  this.atime = (initial &amp;&amp; initial.atime);
  this.mtime = (initial &amp;&amp; initial.mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream" id="apidoc.element.ssh2-streams.SSH2Stream">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>SSH2Stream
        <span class="apidocSignatureSpan">(cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SSH2Stream(cfg) {
  if (typeof cfg !== 'object' || cfg === null)
    cfg = {};

  TransformStream.call(this, {
    highWaterMark: (typeof cfg.highWaterMark === 'number'
                    ? cfg.highWaterMark
                    : 32 * 1024)
  });

  this._needContinue = false;
  this.bytesSent = this.bytesReceived = 0;
  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);
  this.server = (cfg.server === true);
  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'
                        ? cfg.maxPacketSize
                        : MAX_PACKET_SIZE);
  // Bitmap that indicates any bugs the remote side has. This is determined
  // by the reported software version.
  this.remoteBugs = 0;

  if (this.server) {
    // TODO: Remove when we support group exchange for server implementation
    this.remoteBugs = BUGS.BAD_DHGEX;
  }

  var self = this;

  var hostKeys = cfg.hostKeys;
  if (this.server &amp;&amp; (typeof hostKeys !== 'object' || hostKeys === null))
    throw new Error('hostKeys must be an object keyed on host key type');

  this.config = {
    // Server
    hostKeys: hostKeys, // All keys supported by server

    // Client/Server
    ident: 'SSH-2.0-'
           + (cfg.ident
              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),
    algorithms: {
      kex: ALGORITHMS.KEX,
      kexBuf: ALGORITHMS.KEX_BUF,
      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,
      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,
      cipher: ALGORITHMS.CIPHER,
      cipherBuf: ALGORITHMS.CIPHER_BUF,
      hmac: ALGORITHMS.HMAC,
      hmacBuf: ALGORITHMS.HMAC_BUF,
      compress: ALGORITHMS.COMPRESS,
      compressBuf: ALGORITHMS.COMPRESS_BUF
    }
  };
  // RFC 4253 states the identification string must not contain NULL
  this.config.ident.replace(RE_NULL, '');

  if (this.config.ident.length + 2 /* Account for "\r\n" */ &gt; 255)
    throw new Error('ident too long');

  if (typeof cfg.algorithms === 'object' &amp;&amp; cfg.algorithms !== null) {
    var algos = cfg.algorithms;
    if (Array.isArray(algos.kex) &amp;&amp; algos.kex.length &gt; 0) {
      this.config.algorithms.kex = algos.kex;
      if (!Buffer.isBuffer(algos.kexBuf))
        algos.kexBuf = new Buffer(algos.kex.join(','), 'ascii');
      this.config.algorithms.kexBuf = algos.kexBuf;
    }
    if (Array.isArray(algos.serverHostKey) &amp;&amp; algos.serverHostKey.length &gt; 0) {
      this.config.algorithms.serverHostKey = algos.serverHostKey;
      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {
        algos.serverHostKeyBuf = new Buffer(algos.serverHostKey.join(','),
                                            'ascii');
      }
      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;
    }
    if (Array.isArray(algos.cipher) &amp;&amp; algos.cipher.length &gt; 0) {
      this.config.algorithms.cipher = algos.cipher;
      if (!Buffer.isBuffer(algos.cipherBuf))
        algos.cipherBuf = new Buffer(algos.cipher.join(','), 'ascii');
      this.config.algorithms.cipherBuf = algos.cipherBuf;
    }
    if (Array.isArray(algos.hmac) &amp;&amp; algos.hmac.length &gt; 0) {
      this.config.algorithms.hmac = algos.hmac;
      if (!Buffer.isBuffer(algos.hmacBuf))
        algos.hmacBuf = new Buffer(algos.hmac.join(','), 'ascii');
      this.config.algorithms.hmacBuf = algos.hmacBuf;
    }
    if (Array.isArray(algos.compress) &amp;&amp; algos.compress.length &gt; 0) {
      this.config.algorithms.compress = algos.compress;
      if (!Buffer.isBuffer(algos.compressBuf))
        algos.compressBuf = new Buffer(algos.compress.join(','), 'ascii');
      this.config.algorithms.compressBuf = algos.compressBuf;
    }
  }

  this.reset(true);

  // Common events
  this.on('end', function() {
    // Let GC collect any Buffers we were previously storing
    self._state = undefined;
    self.reset();
    self._state.incoming.hmac.bufCompute = undefined;
    self._state.outgoing.bufSeqno = undefined;
  });
  this.on('DISCONNECT', function(reason, code, desc, lang) {
    onDISCONNECT(self, reason, code, desc, lang);
  });
  this.on('KEXINIT', function(init, firstFollows) {
    onKEXINIT(self, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn" id="apidoc.element.ssh2-streams.jsbn">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>jsbn
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SFTPStream" id="apidoc.module.ssh2-streams.SFTPStream">module ssh2-streams.SFTPStream</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.SFTPStream" id="apidoc.element.ssh2-streams.SFTPStream.SFTPStream">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>SFTPStream
        <span class="apidocSignatureSpan">(cfg, remoteIdentRaw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SFTPStream(cfg, remoteIdentRaw) {
  if (typeof cfg === 'string' &amp;&amp; !remoteIdentRaw) {
    remoteIdentRaw = cfg;
    cfg = undefined;
  }
  if (typeof cfg !== 'object' || !cfg)
    cfg = {};

  TransformStream.call(this, {
    highWaterMark: (typeof cfg.highWaterMark === 'number'
                    ? cfg.highWaterMark
                    : 32 * 1024)
  });

  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);
  this.server = (cfg.server ? true : false);
  this._isOpenSSH = (remoteIdentRaw &amp;&amp; RE_OPENSSH.test(remoteIdentRaw));
  this._needContinue = false;
  this._state = {
    // common
    status: 'packet_header',
    writeReqid: -1,
    pktLeft: undefined,
    pktHdrBuf: new Buffer(9), // room for pktLen + pktType + req id
    pktBuf: undefined,
    pktType: undefined,
    version: undefined,
    extensions: {},

    // client
    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),
    requests: {}
  };

  var self = this;
  this.on('end', function() {
    self.readable = false;
  }).on('finish', onFinish)
    .on('prefinish', onFinish);
  function onFinish() {
    self.writable = false;
    self._cleanup(false);
  }

  if (!this.server)
    this.push(CLIENT_VERSION_BUFFER);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats" id="apidoc.element.ssh2-streams.SFTPStream.Stats">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>Stats
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats(initial) {
  this.mode = (initial &amp;&amp; initial.mode);
  this.permissions = this.mode; // backwards compatiblity
  this.uid = (initial &amp;&amp; initial.uid);
  this.gid = (initial &amp;&amp; initial.gid);
  this.size = (initial &amp;&amp; initial.size);
  this.atime = (initial &amp;&amp; initial.atime);
  this.mtime = (initial &amp;&amp; initial.mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.flagsToString" id="apidoc.element.ssh2-streams.SFTPStream.flagsToString">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>flagsToString
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flagsToString(flags) {
  for (var i = 0; i &lt; stringFlagMapKeys.length; ++i) {
    var key = stringFlagMapKeys[i];
    if (stringFlagMap[key] === flags)
      return key;
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.stringToFlags" id="apidoc.element.ssh2-streams.SFTPStream.stringToFlags">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>stringToFlags
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringToFlags(str) {
  var flags = stringFlagMap[str];
  if (flags !== undefined)
    return flags;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.super_" id="apidoc.element.ssh2-streams.SFTPStream.super_">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SFTPStream.Stats" id="apidoc.module.ssh2-streams.SFTPStream.Stats">module ssh2-streams.SFTPStream.Stats</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.Stats" id="apidoc.element.ssh2-streams.SFTPStream.Stats.Stats">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.</span>Stats
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats(initial) {
  this.mode = (initial &amp;&amp; initial.mode);
  this.permissions = this.mode; // backwards compatiblity
  this.uid = (initial &amp;&amp; initial.uid);
  this.gid = (initial &amp;&amp; initial.gid);
  this.size = (initial &amp;&amp; initial.size);
  this.atime = (initial &amp;&amp; initial.atime);
  this.mtime = (initial &amp;&amp; initial.mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SFTPStream.Stats.prototype" id="apidoc.module.ssh2-streams.SFTPStream.Stats.prototype">module ssh2-streams.SFTPStream.Stats.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype._checkModeProperty" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype._checkModeProperty">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>_checkModeProperty
        <span class="apidocSignatureSpan">(property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkModeProperty = function (property) {
  return ((this.mode &amp; constants.S_IFMT) === property);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isBlockDevice" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isBlockDevice">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isBlockDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBlockDevice = function () {
  return this._checkModeProperty(constants.S_IFBLK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isCharacterDevice" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isCharacterDevice">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isCharacterDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCharacterDevice = function () {
  return this._checkModeProperty(constants.S_IFCHR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isDirectory" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isDirectory">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectory = function () {
  return this._checkModeProperty(constants.S_IFDIR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFIFO" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFIFO">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isFIFO
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFIFO = function () {
  return this._checkModeProperty(constants.S_IFIFO);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFile" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isFile">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFile = function () {
  return this._checkModeProperty(constants.S_IFREG);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSocket" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSocket">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSocket = function () {
  return this._checkModeProperty(constants.S_IFSOCK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSymbolicLink" id="apidoc.element.ssh2-streams.SFTPStream.Stats.prototype.isSymbolicLink">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.Stats.prototype.</span>isSymbolicLink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSymbolicLink = function () {
  return this._checkModeProperty(constants.S_IFLNK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SFTPStream.prototype" id="apidoc.module.ssh2-streams.SFTPStream.prototype">module ssh2-streams.SFTPStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.__push" id="apidoc.element.ssh2-streams.SFTPStream.prototype.__push">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>__push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.__read" id="apidoc.element.ssh2-streams.SFTPStream.prototype.__read">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>__read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype._cleanup" id="apidoc.element.ssh2-streams.SFTPStream.prototype._cleanup">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_cleanup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanup = function (callback) {
  var state = this._state;

  state.pktBuf = undefined; // give GC something to do

  var requests = state.requests;
  var keys = Object.keys(requests);
  var len = keys.length;
  if (len) {
    if (this.readable) {
      var err = new Error('SFTP session ended early');
      for (var i = 0, cb; i &lt; len; ++i)
        (cb = requests[keys[i]].cb) &amp;&amp; cb(err);
    }
    state.requests = {};
  }

  if (this.readable)
    this.push(null);
  else if (!this._readableState.endEmitted &amp;&amp; !this._readableState.flowing) {
    // Ugh!
    this.resume();
  }
  if (callback !== false) {
    this.debug('DEBUG[SFTP]: Parser: Malformed packet');
    callback &amp;&amp; callback(new Error('Malformed packet'));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype._read" id="apidoc.element.ssh2-streams.SFTPStream.prototype._read">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  if (this._needContinue) {
    this._needContinue = false;
    this.emit('continue');
  }
  return this.__read(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype._transform" id="apidoc.element.ssh2-streams.SFTPStream.prototype._transform">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  var state = this._state;
  var server = this.server;
  var status = state.status;
  var pktType = state.pktType;
  var pktBuf = state.pktBuf;
  var pktLeft = state.pktLeft;
  var version = state.version;
  var pktHdrBuf = state.pktHdrBuf;
  var requests = state.requests;
  var debug = this.debug;
  var chunkLen = chunk.length;
  var chunkPos = 0;
  var buffer;
  var chunkLeft;
  var id;

  while (true) {
    if (status === 'discard') {
      chunkLeft = (chunkLen - chunkPos);
      if (pktLeft &lt;= chunkLeft) {
        chunkPos += pktLeft;
        pktLeft = 0;
        status = 'packet_header';
        buffer = pktBuf = undefined;
      } else {
        pktLeft -= chunkLeft;
        break;
      }
    } else if (pktBuf !== undefined) {
      chunkLeft = (chunkLen - chunkPos);
      if (pktLeft &lt;= chunkLeft) {
        chunk.copy(pktBuf,
                   pktBuf.length - pktLeft,
                   chunkPos,
                   chunkPos + pktLeft);
        chunkPos += pktLeft;
        pktLeft = 0;
        buffer = pktBuf;
        pktBuf = undefined;
        continue;
      } else {
        chunk.copy(pktBuf, pktBuf.length - pktLeft, chunkPos);
        pktLeft -= chunkLeft;
        break;
      }
    } else if (status === 'packet_header') {
      if (!buffer) {
        pktLeft = 5;
        pktBuf = pktHdrBuf;
      } else {
        // here we read the right-most 5 bytes from buffer (pktHdrBuf)
        pktLeft = buffer.readUInt32BE(4, true) - 1; // account for type byte
        pktType = buffer[8];

        if (server) {
          if (version === undefined &amp;&amp; pktType !== REQUEST.INIT) {
            debug('DEBUG[SFTP]: Parser: Unexpected packet before init');
            status = 'bad_pkt';
          } else if (version !== undefined &amp;&amp; pktType === REQUEST.INIT) {
            debug('DEBUG[SFTP]: Parser: Unexpected duplicate init');
            status = 'bad_pkt';
          } else if (pktLeft &gt; MAX_PKT_LEN) {
            debug('DEBUG[SFTP]: Parser: Packet length ('
                  + pktLeft
                  + ') exceeds max length ('
                  + MAX_PKT_LEN
                  + ')');
            status = 'bad_pkt';
          } else if (pktType === REQUEST.EXTENDED)
            status = 'bad_pkt';
          else if (REQUEST[pktType] === undefined) {
            debug('DEBUG[SFTP]: Parser: Unsupported packet type: ' + pktType);
            status = 'discard';
          }
        } else if (version === undefined &amp;&amp; pktType !== RESPONSE.VERSION) {
          debug('DEBUG[SFTP]: Parser: Unexpected packet before version');
          status = 'bad_pkt';
        } else if (version !== undefined &amp;&amp; pktType === RESPONSE.VERSION) {
          debug('DEBUG[SFTP]: Parser: Unexpected duplicate version');
          status = 'bad_pkt';
        } else if (RESPONSE[pktType] === undefined)
          status = 'discard';

        if (status === 'bad_pkt') {
          // copy original packet info
          pktHdrBuf.writeUInt32BE(pktLeft, 0, true);
          pktHdrBuf[4] = pktType;

          pktLeft = 4;
          pktBuf = pktHdrBuf;
        } else {
          pktBuf = new Buffer(pktLeft);
          status = 'payload';
        }
      }
    } else if (status === 'payload') {
      if (pktType === RESPONSE.VERSION || pktType === REQUEST.INIT) {
<span class="apidocCodeCommentSpan">        /*
          uint32 version
          &lt;extension data&gt;
        */
</span>        version = state.version = readInt(buffer, 0, this, callback);
        if (version === false)
          return;
        if (version &lt; 3) {
          this._cleanup();
          return callback(new Error('Incompatible SFTP version: ' + version));
        } else if (server)
          this.push(SERVER_VERSION_BUFFER);

        var buflen = buffer.length;
        var extname;
        var extdata;
        buffer._pos = 4;
        while (buffer._pos &lt; buflen) {
          extname = readString(buffer, buffer._pos, 'ascii', this, callback);
          if (extname === false)
            return;
          extdata = readString(buffer, buffer._pos, 'ascii', this, callback);
          if (extdata === ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.appendFile" id="apidoc.element.ssh2-streams.SFTPStream.prototype.appendFile">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>appendFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFile = function (path, data, options, callback_) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var callback;
  if (typeof callback_ === 'function') {
    callback = callback_;
  } else if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }

  if (typeof options === 'string')
    options = { encoding: options, mode: 438, flag: 'a' };
  else if (!options)
    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };
  else if (typeof options !== 'object')
    throw new TypeError('Bad arguments');

  if (!options.flag)
    options = util._extend({ flag: 'a' }, options);
  this.writeFile(path, data, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.attrs" id="apidoc.element.ssh2-streams.SFTPStream.prototype.attrs">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>attrs
        <span class="apidocSignatureSpan">(id, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attrs = function (id, attrs) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  if (typeof attrs !== 'object')
    throw new Error('attrs is not an object');

  var info = attrsToBytes(attrs);
  var buf = new Buffer(4 + 1 + 4 + 4 + info.nbytes);
  var p = 13;

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = RESPONSE.ATTRS;
  buf.writeUInt32BE(id, 5, true);

  buf.writeUInt32BE(info.flags, 9, true);

  if (info.flags &amp;&amp; info.bytes) {
    var bytes = info.bytes;
    for (var j = 0, len = bytes.length; j &lt; len; ++j)
      for (var k = 0, len2 = bytes[j].length; k &lt; len2; ++k)
        buf[p++] = bytes[j][k];
  }

  this.debug('DEBUG[SFTP]: Outgoing: Writing ATTRS');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.chmod" id="apidoc.element.ssh2-streams.SFTPStream.prototype.chmod">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>chmod
        <span class="apidocSignatureSpan">(path, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function (path, mode, cb) {
  return this.setstat(path, {
    mode: mode
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.chown" id="apidoc.element.ssh2-streams.SFTPStream.prototype.chown">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>chown
        <span class="apidocSignatureSpan">(path, uid, gid, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function (path, uid, gid, cb) {
  return this.setstat(path, {
    uid: uid,
    gid: gid
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.close" id="apidoc.element.ssh2-streams.SFTPStream.prototype.close">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>close
        <span class="apidocSignatureSpan">(handle, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (handle, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.CLOSE;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(handlelen, p, true);
  handle.copy(buf, p += 4);

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing CLOSE');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.createReadStream" id="apidoc.element.ssh2-streams.SFTPStream.prototype.createReadStream">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (path, options) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  return new ReadStream(this, path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.createWriteStream" id="apidoc.element.ssh2-streams.SFTPStream.prototype.createWriteStream">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (path, options) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  return new WriteStream(this, path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.data" id="apidoc.element.ssh2-streams.SFTPStream.prototype.data">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>data
        <span class="apidocSignatureSpan">(id, data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function (id, data, encoding) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var isBuffer = Buffer.isBuffer(data);

  if (!isBuffer &amp;&amp; typeof data !== 'string')
    throw new Error('data is not a Buffer or string');

  if (!isBuffer)
    encoding || (encoding = 'utf8');

  var dataLen = (isBuffer ? data.length : Buffer.byteLength(data, encoding));
  var buf = new Buffer(4 + 1 + 4 + 4 + dataLen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = RESPONSE.DATA;
  buf.writeUInt32BE(id, 5, true);

  buf.writeUInt32BE(dataLen, 9, true);
  if (dataLen) {
    if (isBuffer)
      data.copy(buf, 13);
    else
      buf.write(data, 13, dataLen, encoding);
  }

  this.debug('DEBUG[SFTP]: Outgoing: Writing DATA');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.exists" id="apidoc.element.ssh2-streams.SFTPStream.prototype.exists">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>exists
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  this.stat(path, function(err) {
    cb &amp;&amp; cb(err ? false : true);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fstatvfs" id="apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fstatvfs">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_fstatvfs
        <span class="apidocSignatureSpan">(handle, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ext_openssh_fstatvfs = function (handle, cb) {
  var state = this._state;

  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!state.extensions['fstatvfs@openssh.com']
           || state.extensions['fstatvfs@openssh.com'].indexOf('2') === -1)
    throw new Error('Server does not support this extended request');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

<span class="apidocCodeCommentSpan">  /*
    uint32    id
    string    "fstatvfs@openssh.com"
    string    handle
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + handlelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.EXTENDED;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);
  buf.writeUInt32BE(20, p, true);
  buf.write('fstatvfs@openssh.com', p += 4, 20, 'ascii');

  buf.writeUInt32BE(handlelen, p += 20, true);
  buf.write(handle, p += 4, handlelen, 'utf8');

  state.requests[reqid] = {
    extended: 'fstatvfs@openssh.com',
    cb: cb
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing fstatvfs@openssh.com');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fsync" id="apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_fsync">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_fsync
        <span class="apidocSignatureSpan">(handle, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ext_openssh_fsync = function (handle, cb) {
  var state = this._state;

  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!state.extensions['fsync@openssh.com']
           || state.extensions['fsync@openssh.com'].indexOf('1') === -1)
    throw new Error('Server does not support this extended request');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

<span class="apidocCodeCommentSpan">  /*
    uint32    id
    string    "fsync@openssh.com"
    string    handle
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + 17 + 4 + handlelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.EXTENDED;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);
  buf.writeUInt32BE(17, p, true);
  buf.write('fsync@openssh.com', p += 4, 17, 'ascii');

  buf.writeUInt32BE(handlelen, p += 17, true);
  buf.write(handle, p += 4, handlelen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing fsync@openssh.com');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_hardlink" id="apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_hardlink">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_hardlink
        <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ext_openssh_hardlink = function (oldPath, newPath, cb) {
  var state = this._state;

  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!state.extensions['hardlink@openssh.com']
           || state.extensions['hardlink@openssh.com'].indexOf('1') === -1)
    throw new Error('Server does not support this extended request');

<span class="apidocCodeCommentSpan">  /*
    uint32    id
    string    "hardlink@openssh.com"
    string    oldpath
    string    newpath
  */
</span>  var oldlen = Buffer.byteLength(oldPath);
  var newlen = Buffer.byteLength(newPath);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + oldlen + 4 + newlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.EXTENDED;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);
  buf.writeUInt32BE(20, p, true);
  buf.write('hardlink@openssh.com', p += 4, 20, 'ascii');

  buf.writeUInt32BE(oldlen, p += 20, true);
  buf.write(oldPath, p += 4, oldlen, 'utf8');
  buf.writeUInt32BE(newlen, p += oldlen, true);
  buf.write(newPath, p += 4, newlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing hardlink@openssh.com');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_rename" id="apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_rename">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_rename
        <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ext_openssh_rename = function (oldPath, newPath, cb) {
  var state = this._state;

  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!state.extensions['posix-rename@openssh.com']
           || state.extensions['posix-rename@openssh.com'].indexOf('1') === -1)
    throw new Error('Server does not support this extended request');

<span class="apidocCodeCommentSpan">  /*
    uint32    id
    string    "posix-rename@openssh.com"
    string    oldpath
    string    newpath
  */
</span>  var oldlen = Buffer.byteLength(oldPath);
  var newlen = Buffer.byteLength(newPath);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + 24 + 4 + oldlen + 4 + newlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.EXTENDED;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);
  buf.writeUInt32BE(24, p, true);
  buf.write('posix-rename@openssh.com', p += 4, 24, 'ascii');

  buf.writeUInt32BE(oldlen, p += 24, true);
  buf.write(oldPath, p += 4, oldlen, 'utf8');
  buf.writeUInt32BE(newlen, p += oldlen, true);
  buf.write(newPath, p += 4, newlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing posix-rename@openssh.com');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_statvfs" id="apidoc.element.ssh2-streams.SFTPStream.prototype.ext_openssh_statvfs">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>ext_openssh_statvfs
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ext_openssh_statvfs = function (path, cb) {
  var state = this._state;

  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!state.extensions['statvfs@openssh.com']
           || state.extensions['statvfs@openssh.com'].indexOf('2') === -1)
    throw new Error('Server does not support this extended request');

<span class="apidocCodeCommentSpan">  /*
    uint32    id
    string    "statvfs@openssh.com"
    string    path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + 19 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.EXTENDED;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);
  buf.writeUInt32BE(19, p, true);
  buf.write('statvfs@openssh.com', p += 4, 19, 'ascii');

  buf.writeUInt32BE(pathlen, p += 19, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = {
    extended: 'statvfs@openssh.com',
    cb: cb
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing statvfs@openssh.com');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fastGet" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fastGet">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fastGet
        <span class="apidocSignatureSpan">(remotePath, localPath, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fastGet = function (remotePath, localPath, opts, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  fastXfer(this, fs, remotePath, localPath, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fastPut" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fastPut">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fastPut
        <span class="apidocSignatureSpan">(localPath, remotePath, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fastPut = function (localPath, remotePath, opts, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  fastXfer(fs, this, localPath, remotePath, opts, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fchmod" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fchmod">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fchmod
        <span class="apidocSignatureSpan">(handle, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmod = function (handle, mode, cb) {
  return this.fsetstat(handle, {
    mode: mode
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fchown" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fchown">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fchown
        <span class="apidocSignatureSpan">(handle, uid, gid, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchown = function (handle, uid, gid, cb) {
  return this.fsetstat(handle, {
    uid: uid,
    gid: gid
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fsetstat" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fsetstat">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fsetstat
        <span class="apidocSignatureSpan">(handle, attrs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsetstat = function (handle, attrs, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

  var flags = 0;
  var attrBytes = 0;
  var state = this._state;

  if (typeof attrs === 'object') {
    attrs = attrsToBytes(attrs);
    flags = attrs.flags;
    attrBytes = attrs.nbytes;
    attrs = attrs.bytes;
  } else if (typeof attrs === 'function')
    cb = attrs;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
    ATTRS      attrs
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen + 4 + attrBytes);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.FSETSTAT;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(handlelen, p, true);
  handle.copy(buf, p += 4);
  buf.writeUInt32BE(flags, p += handlelen);
  if (flags) {
    p += 4;
    for (var i = 0, len = attrs.length; i &lt; len; ++i)
      for (var j = 0, len2 = attrs[i].length; j &lt; len2; ++j)
        buf[p++] = attrs[i][j];
  }

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing FSETSTAT');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.fstat" id="apidoc.element.ssh2-streams.SFTPStream.prototype.fstat">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>fstat
        <span class="apidocSignatureSpan">(handle, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstat = function (handle, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.FSTAT;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(handlelen, p, true);
  handle.copy(buf, p += 4);

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing FSTAT');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.futimes" id="apidoc.element.ssh2-streams.SFTPStream.prototype.futimes">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>futimes
        <span class="apidocSignatureSpan">(handle, atime, mtime, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimes = function (handle, atime, mtime, cb) {
  return this.fsetstat(handle, {
    atime: toUnixTimestamp(atime),
    mtime: toUnixTimestamp(mtime)
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.handle" id="apidoc.element.ssh2-streams.SFTPStream.prototype.handle">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>handle
        <span class="apidocSignatureSpan">(id, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function (id, handle) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');

  var handleLen = handle.length;

  if (handleLen &gt; 256)
    throw new Error('handle too large (&gt; 256 bytes)');

  var buf = new Buffer(4 + 1 + 4 + 4 + handleLen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = RESPONSE.HANDLE;
  buf.writeUInt32BE(id, 5, true);

  buf.writeUInt32BE(handleLen, 9, true);
  if (handleLen)
    handle.copy(buf, 13);

  this.debug('DEBUG[SFTP]: Outgoing: Writing HANDLE');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.lstat" id="apidoc.element.ssh2-streams.SFTPStream.prototype.lstat">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>lstat
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstat = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.LSTAT;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing LSTAT');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.mkdir" id="apidoc.element.ssh2-streams.SFTPStream.prototype.mkdir">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>mkdir
        <span class="apidocSignatureSpan">(path, attrs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function (path, attrs, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var flags = 0;
  var attrBytes = 0;
  var state = this._state;

  if (typeof attrs === 'function') {
    cb = attrs;
    attrs = undefined;
  }
  if (typeof attrs === 'object') {
    attrs = attrsToBytes(attrs);
    flags = attrs.flags;
    attrBytes = attrs.nbytes;
    attrs = attrs.bytes;
  }

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
    ATTRS      attrs
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.MKDIR;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');
  buf.writeUInt32BE(flags, p += pathlen);
  if (flags) {
    p += 4;
    for (var i = 0, len = attrs.length; i &lt; len; ++i)
      for (var j = 0, len2 = attrs[i].length; j &lt; len2; ++j)
        buf[p++] = attrs[i][j];
  }

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing MKDIR');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.name" id="apidoc.element.ssh2-streams.SFTPStream.prototype.name">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>name
        <span class="apidocSignatureSpan">(id, names)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name = function (id, names) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  if (!Array.isArray(names) &amp;&amp; typeof names === 'object')
    names = [ names ];
  else if (!Array.isArray(names))
    throw new Error('names is not an object or array');

  var count = names.length;
  var namesLen = 0;
  var nameAttrs;
  var attrs = [];
  var name;
  var filename;
  var longname;
  var attr;
  var len;
  var len2;
  var buf;
  var p;
  var i;
  var j;
  var k;

  for (i = 0; i &lt; count; ++i) {
    name = names[i];
    filename = (!name || !name.filename || typeof name.filename !== 'string'
                ? ''
                : name.filename);
    namesLen += 4 + Buffer.byteLength(filename);
    longname = (!name || !name.longname || typeof name.longname !== 'string'
                ? ''
                : name.longname);
    namesLen += 4 + Buffer.byteLength(longname);

    if (typeof name.attrs === 'object') {
      nameAttrs = attrsToBytes(name.attrs);
      namesLen += 4 + nameAttrs.nbytes;
      attrs.push(nameAttrs);
    } else {
      namesLen += 4;
      attrs.push(null);
    }
  }

  buf = new Buffer(4 + 1 + 4 + 4 + namesLen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = RESPONSE.NAME;
  buf.writeUInt32BE(id, 5, true);

  buf.writeUInt32BE(count, 9, true);

  p = 13;

  for (i = 0; i &lt; count; ++i) {
    name = names[i];

    filename = (!name || !name.filename || typeof name.filename !== 'string'
                ? ''
                : name.filename);
    len = Buffer.byteLength(filename);
    buf.writeUInt32BE(len, p, true);
    p += 4;
    if (len) {
      buf.write(filename, p, len, 'utf8');
      p += len;
    }

    longname = (!name || !name.longname || typeof name.longname !== 'string'
                ? ''
                : name.longname);
    len = Buffer.byteLength(longname);
    buf.writeUInt32BE(len, p, true);
    p += 4;
    if (len) {
      buf.write(longname, p, len, 'utf8');
      p += len;
    }

    attr = attrs[i];
    if (attr) {
      buf.writeUInt32BE(attr.flags, p, true);
      p += 4;
      if (attr.flags &amp;&amp; attr.bytes) {
        var bytes = attr.bytes;
        for (j = 0, len = bytes.length; j &lt; len; ++j)
          for (k = 0, len2 = bytes[j].length; k &lt; len2; ++k)
            buf[p++] = bytes[j][k];
      }
    } else {
      buf.writeUInt32BE(0, p, true);
      p += 4;
    }
  }

  this.debug('DEBUG[SFTP]: Outgoing: Writing NAME');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.open" id="apidoc.element.ssh2-streams.SFTPStream.prototype.open">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>open
        <span class="apidocSignatureSpan">(path, flags_, attrs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (path, flags_, attrs, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

  if (typeof attrs === 'function') {
    cb = attrs;
    attrs = undefined;
  }

  var flags = stringToFlags(flags_);
  if (flags === null)
    throw new Error('Unknown flags string: ' + flags_);

  var attrFlags = 0;
  var attrBytes = 0;
  if (typeof attrs === 'string' || typeof attrs === 'number') {
    attrs = { mode: attrs };
  }
  if (typeof attrs === 'object') {
    attrs = attrsToBytes(attrs);
    attrFlags = attrs.flags;
    attrBytes = attrs.nbytes;
    attrs = attrs.bytes;
  }

<span class="apidocCodeCommentSpan">  /*
    uint32        id
    string        filename
    uint32        pflags
    ATTRS         attrs
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + 4 + attrBytes);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.OPEN;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');
  buf.writeUInt32BE(flags, p += pathlen, true);
  buf.writeUInt32BE(attrFlags, p += 4, true);
  if (attrs &amp;&amp; attrFlags) {
    p += 4;
    for (var i = 0, len = attrs.length; i &lt; len; ++i)
      for (var j = 0, len2 = attrs[i].length; j &lt; len2; ++j)
        buf[p++] = attrs[i][j];
  }
  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing OPEN');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.opendir" id="apidoc.element.ssh2-streams.SFTPStream.prototype.opendir">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>opendir
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">opendir = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.OPENDIR;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing OPENDIR');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.push" id="apidoc.element.ssh2-streams.SFTPStream.prototype.push">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk, encoding) {
  if (!this.readable)
    return false;
  if (chunk === null)
    this.readable = false;
  var ret = this.__push(chunk, encoding);
  this._needContinue = (ret === false);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var SUPPORTED_SERVER_HOST_KEY = [
  'ssh-dss'
];
if (semver.gte(process.version, '5.2.0')) {
  // ECDSA keys are only supported in v5.2.0+ because of a crypto change that
  // made it possible to (efficiently) generate an ECDSA public key from a
  // private key (commit nodejs/node#da5ac55c83eb2c09cfb3baf7875529e8f1113529)
  DEFAULT_SERVER_HOST_KEY.<span class="apidocCodeKeywordSpan">push</span>(
    'ecdsa-sha2-nistp256',
    'ecdsa-sha2-nistp384',
    'ecdsa-sha2-nistp521'
  );
}
var SERVER_HOST_KEY_BUF = new Buffer(DEFAULT_SERVER_HOST_KEY.join(','),
'ascii');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readData" id="apidoc.element.ssh2-streams.SFTPStream.prototype.readData">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readData
        <span class="apidocSignatureSpan">(handle, buf, off, len, position, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readData = function (handle, buf, off, len, position, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');
  else if (!Buffer.isBuffer(buf))
    throw new Error('buffer is not a Buffer');
  else if (off &gt;= buf.length)
    throw new Error('offset is out of bounds');
  else if (off + len &gt; buf.length)
    throw new Error('length extends beyond buffer');
  else if (position === null)
    throw new Error('null position currently unsupported');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
    uint64     offset
    uint32     len
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var pos = position;
  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4);

  out.writeUInt32BE(out.length - 4, 0, true);
  out[4] = REQUEST.READ;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  out.writeUInt32BE(reqid, 5, true);

  out.writeUInt32BE(handlelen, p, true);
  handle.copy(out, p += 4);
  p += handlelen;
  for (var i = 7; i &gt;= 0; --i) {
    out[p + i] = pos &amp; 0xFF;
    pos /= 256;
  }
  out.writeUInt32BE(len, p += 8, true);

  state.requests[reqid] = {
    cb: function(err, data, nb) {
      if (err &amp;&amp; err.code !== STATUS_CODE.EOF)
        return cb(err);
      cb(undefined, nb || 0, data, position);
    },
    buffer: buf.slice(off, off + len)
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing READ');
  return this.push(out);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readFile" id="apidoc.element.ssh2-streams.SFTPStream.prototype.readFile">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readFile
        <span class="apidocSignatureSpan">(path, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, options, callback_) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var callback;
  if (typeof callback_ === 'function') {
    callback = callback_;
  } else if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }

  var self = this;

  if (typeof options === 'string')
    options = { encoding: options, flag: 'r' };
  else if (!options)
    options = { encoding: null, flag: 'r' };
  else if (typeof options !== 'object')
    throw new TypeError('Bad arguments');

  var encoding = options.encoding;
  if (encoding &amp;&amp; !Buffer.isEncoding(encoding))
    throw new Error('Unknown encoding: ' + encoding);

  // first, stat the file, so we know the size.
  var size;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown
  var pos = 0;
  var handle;

  // SFTPv3 does not support using -1 for read position, so we have to track
  // read position manually
  var bytesRead = 0;

  var flag = options.flag || 'r';
  this.open(path, flag, 438 /*=0666*/, function(er, handle_) {
    if (er)
      return callback &amp;&amp; callback(er);
    handle = handle_;

    self.fstat(handle, function tryStat(er, st) {
      if (er) {
        // Try stat() for sftp servers that may not support fstat() for
        // whatever reason
        self.stat(path, function(er_, st_) {
          if (er_) {
            return self.close(handle, function() {
              callback &amp;&amp; callback(er);
            });
          }
          tryStat(null, st_);
        });
        return;
      }

      size = st.size;
      if (size === 0) {
        // the kernel lies about many files.
        // Go ahead and try to read some bytes.
        buffers = [];
        return read();
      }

      buffer = new Buffer(size);
      read();
    });
  });

  function read() {
    if (size === 0) {
      buffer = new Buffer(8192);
      self.readData(handle, buffer, 0, 8192, bytesRead, afterRead);
    } else
      self.readData(handle, buffer, pos, size - pos, bytesRead, afterRead);
  }

  function afterRead(er, nbytes) {
    if (er) {
      return self.close(handle, function() {
        return callback &amp;&amp; callback(er);
      });
    }

    if (nbytes === 0)
      return close();

    bytesRead += nbytes;
    pos += nbytes;
    if (size !== 0) {
      if (pos === size)
        close();
      else
        read();
    } else {
      // unknown size, just read until we don't get bytes.
      buffers.push(buffer.slice(0, nbytes));
      read();
    }
  }

  function close() {
    self.close(handle, function(er) {
      if (size === 0) {
        // collected the data into the buffers list.
        buffer = Buffer.concat(buffers, pos);
      } else if (pos &lt; size)
        buffer = buffer.slice(0, pos);

      if (encoding)
        buffer = buffer.toString(encoding);
      return callback &amp;&amp; callback(er, buffer);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readdir" id="apidoc.element.ssh2-streams.SFTPStream.prototype.readdir">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readdir
        <span class="apidocSignatureSpan">(where, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdir = function (where, opts, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;
  var doFilter;

  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof opts !== 'object')
    opts = {};

  doFilter = (opts &amp;&amp; opts.full ? false : true);

  if (!Buffer.isBuffer(where) &amp;&amp; typeof where !== 'string')
    throw new Error('missing directory handle or path');

  if (typeof where === 'string') {
    var self = this;
    var entries = [];
    var e = 0;

    return this.opendir(where, function reread(err, handle) {
      if (err)
        return cb(err);

      self.readdir(handle, opts, function(err, list) {
        var eof = (err &amp;&amp; err.code === STATUS_CODE.EOF);

        if (err &amp;&amp; !eof) {
          return self.close(handle, function() {
            cb(err);
          });
        } else if (eof) {
          return self.close(handle, function(err) {
            if (err)
              return cb(err);
            cb(undefined, entries);
          });
        }

        for (var i = 0, len = list.length; i &lt; len; ++i, ++e)
          entries[e] = list[i];

        reread(undefined, handle);
      });
    });
  }

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
  */
</span>  var handlelen = where.length;
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.READDIR;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(handlelen, p, true);
  where.copy(buf, p += 4);

  state.requests[reqid] = {
    cb: (doFilter
         ? function(err, list) {
             if (err)
               return cb(err);

             for (var i = list.length - 1; i &gt;= 0; --i) {
               if (list[i].filename === '.' || list[i].filename === '..')
                 list.splice(i, 1);
             }

             cb(undefined, list);
           }
         : cb)
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing READDIR');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.readlink" id="apidoc.element.ssh2-streams.SFTPStream.prototype.readlink">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>readlink
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.READLINK;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = {
    cb: function(err, names) {
      if (err)
        return cb(err);
      else if (!names || !names.length)
        return cb(new Error('Response missing link info'));
      cb(undefined, names[0].filename);
    }
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing READLINK');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.realpath" id="apidoc.element.ssh2-streams.SFTPStream.prototype.realpath">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>realpath
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">realpath = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.REALPATH;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = {
    cb: function(err, names) {
      if (err)
        return cb(err);
      else if (!names || !names.length)
        return cb(new Error('Response missing path info'));
      cb(undefined, names[0].filename);
    }
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing REALPATH');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.rename" id="apidoc.element.ssh2-streams.SFTPStream.prototype.rename">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>rename
        <span class="apidocSignatureSpan">(oldPath, newPath, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (oldPath, newPath, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     oldpath
    string     newpath
  */
</span>  var oldlen = Buffer.byteLength(oldPath);
  var newlen = Buffer.byteLength(newPath);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + oldlen + 4 + newlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.RENAME;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(oldlen, p, true);
  buf.write(oldPath, p += 4, oldlen, 'utf8');
  buf.writeUInt32BE(newlen, p += oldlen, true);
  buf.write(newPath, p += 4, newlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing RENAME');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.rmdir" id="apidoc.element.ssh2-streams.SFTPStream.prototype.rmdir">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>rmdir
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.RMDIR;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing RMDIR');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.setstat" id="apidoc.element.ssh2-streams.SFTPStream.prototype.setstat">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>setstat
        <span class="apidocSignatureSpan">(path, attrs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setstat = function (path, attrs, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var flags = 0;
  var attrBytes = 0;
  var state = this._state;

  if (typeof attrs === 'object') {
    attrs = attrsToBytes(attrs);
    flags = attrs.flags;
    attrBytes = attrs.nbytes;
    attrs = attrs.bytes;
  } else if (typeof attrs === 'function')
    cb = attrs;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
    ATTRS      attrs
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.SETSTAT;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');
  buf.writeUInt32BE(flags, p += pathlen);
  if (flags) {
    p += 4;
    for (var i = 0, len = attrs.length; i &lt; len; ++i)
      for (var j = 0, len2 = attrs[i].length; j &lt; len2; ++j)
        buf[p++] = attrs[i][j];
  }

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing SETSTAT');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.stat" id="apidoc.element.ssh2-streams.SFTPStream.prototype.stat">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>stat
        <span class="apidocSignatureSpan">(path, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     path
  */
</span>  var pathlen = Buffer.byteLength(path);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.STAT;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(path, p += 4, pathlen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing STAT');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.status" id="apidoc.element.ssh2-streams.SFTPStream.prototype.status">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>status
        <span class="apidocSignatureSpan">(id, code, message, lang)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">status = function (id, code, message, lang) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  if (!STATUS_CODE[code] || typeof code !== 'number')
    throw new Error('Bad status code: ' + code);

  message || (message = '');
  lang || (lang = '');

  var msgLen = Buffer.byteLength(message);
  var langLen = Buffer.byteLength(lang);
  var buf = new Buffer(4 + 1 + 4 + 4 + 4 + msgLen + 4 + langLen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = RESPONSE.STATUS;
  buf.writeUInt32BE(id, 5, true);

  buf.writeUInt32BE(code, 9, true);

  buf.writeUInt32BE(msgLen, 13, true);
  if (msgLen)
    buf.write(message, 17, msgLen, 'utf8');

  buf.writeUInt32BE(langLen, 17 + msgLen, true);
  if (langLen)
    buf.write(lang, 17 + msgLen + 4, langLen, 'ascii');

  this.debug('DEBUG[SFTP]: Outgoing: Writing STATUS');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.symlink" id="apidoc.element.ssh2-streams.SFTPStream.prototype.symlink">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>symlink
        <span class="apidocSignatureSpan">(targetPath, linkPath, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (targetPath, linkPath, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     linkpath
    string     targetpath
  */
</span>  var linklen = Buffer.byteLength(linkPath);
  var targetlen = Buffer.byteLength(targetPath);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + linklen + 4 + targetlen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.SYMLINK;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  if (this._isOpenSSH) {
    // OpenSSH has linkpath and targetpath positions switched
    buf.writeUInt32BE(targetlen, p, true);
    buf.write(targetPath, p += 4, targetlen, 'utf8');
    buf.writeUInt32BE(linklen, p += targetlen, true);
    buf.write(linkPath, p += 4, linklen, 'utf8');
  } else {
    buf.writeUInt32BE(linklen, p, true);
    buf.write(linkPath, p += 4, linklen, 'utf8');
    buf.writeUInt32BE(targetlen, p += linklen, true);
    buf.write(targetPath, p += 4, targetlen, 'utf8');
  }

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing SYMLINK');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.unlink" id="apidoc.element.ssh2-streams.SFTPStream.prototype.unlink">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>unlink
        <span class="apidocSignatureSpan">(filename, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (filename, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var state = this._state;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     filename
  */
</span>  var fnamelen = Buffer.byteLength(filename);
  var p = 9;
  var buf = new Buffer(4 + 1 + 4 + 4 + fnamelen);

  buf.writeUInt32BE(buf.length - 4, 0, true);
  buf[4] = REQUEST.REMOVE;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  buf.writeUInt32BE(reqid, 5, true);

  buf.writeUInt32BE(fnamelen, p, true);
  buf.write(filename, p += 4, fnamelen, 'utf8');

  state.requests[reqid] = { cb: cb };

  this.debug('DEBUG[SFTP]: Outgoing: Writing REMOVE');
  return this.push(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.utimes" id="apidoc.element.ssh2-streams.SFTPStream.prototype.utimes">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>utimes
        <span class="apidocSignatureSpan">(path, atime, mtime, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimes = function (path, atime, mtime, cb) {
  return this.setstat(path, {
    atime: toUnixTimestamp(atime),
    mtime: toUnixTimestamp(mtime)
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.writeData" id="apidoc.element.ssh2-streams.SFTPStream.prototype.writeData">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>writeData
        <span class="apidocSignatureSpan">(handle, buf, off, len, position, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeData = function (handle, buf, off, len, position, cb) {
  if (this.server)
    throw new Error('Client-only method called in server mode');
  else if (!Buffer.isBuffer(handle))
    throw new Error('handle is not a Buffer');
  else if (!Buffer.isBuffer(buf))
    throw new Error('buffer is not a Buffer');
  else if (off &gt; buf.length)
    throw new Error('offset is out of bounds');
  else if (off + len &gt; buf.length)
    throw new Error('length extends beyond buffer');
  else if (position === null)
    throw new Error('null position currently unsupported');

  var self = this;
  var state = this._state;

  if (!len) {
    cb &amp;&amp; process.nextTick(function() { cb(undefined, 0); });
    return;
  }

  var overflow = (len &gt; state.maxDataLen
                  ? len - state.maxDataLen
                  : 0);
  var origPosition = position;

  if (overflow)
    len = state.maxDataLen;

<span class="apidocCodeCommentSpan">  /*
    uint32     id
    string     handle
    uint64     offset
    string     data
  */
</span>  var handlelen = handle.length;
  var p = 9;
  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4 + len);

  out.writeUInt32BE(out.length - 4, 0, true);
  out[4] = REQUEST.WRITE;
  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;
  out.writeUInt32BE(reqid, 5, true);

  out.writeUInt32BE(handlelen, p, true);
  handle.copy(out, p += 4);
  p += handlelen;
  for (var i = 7; i &gt;= 0; --i) {
    out[p + i] = position &amp; 0xFF;
    position /= 256;
  }
  out.writeUInt32BE(len, p += 8, true);
  buf.copy(out, p += 4, off, off + len);

  state.requests[reqid] = {
    cb: function(err) {
      if (err)
        cb &amp;&amp; cb(err);
      else if (overflow) {
        self.writeData(handle,
                       buf,
                       off + len,
                       overflow,
                       origPosition + len,
                       cb);
      } else
        cb &amp;&amp; cb(undefined, off + len);
    }
  };

  this.debug('DEBUG[SFTP]: Outgoing: Writing WRITE');
  return this.push(out);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SFTPStream.prototype.writeFile" id="apidoc.element.ssh2-streams.SFTPStream.prototype.writeFile">
        function <span class="apidocSignatureSpan">ssh2-streams.SFTPStream.prototype.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, data, options, callback_) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var callback;
  if (typeof callback_ === 'function') {
    callback = callback_;
  } else if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }
  var self = this;

  if (typeof options === 'string')
    options = { encoding: options, mode: 438, flag: 'w' };
  else if (!options)
    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };
  else if (typeof options !== 'object')
    throw new TypeError('Bad arguments');

  if (options.encoding &amp;&amp; !Buffer.isEncoding(options.encoding))
    throw new Error('Unknown encoding: ' + options.encoding);

  var flag = options.flag || 'w';
  this.open(path, flag, options.mode, function(openErr, handle) {
    if (openErr)
      callback &amp;&amp; callback(openErr);
    else {
      var buffer = (Buffer.isBuffer(data)
                    ? data
                    : new Buffer('' + data, options.encoding || 'utf8'));
      var position = (/a/.test(flag) ? null : 0);

      // SFTPv3 does not support the notion of 'current position'
      // (null position), so we just attempt to append to the end of the file
      // instead
      if (position === null) {
        self.fstat(handle, function tryStat(er, st) {
          if (er) {
            // Try stat() for sftp servers that may not support fstat() for
            // whatever reason
            self.stat(path, function(er_, st_) {
              if (er_) {
                return self.close(handle, function() {
                  callback &amp;&amp; callback(er);
                });
              }
              tryStat(null, st_);
            });
            return;
          }
          writeAll(self, handle, buffer, 0, buffer.length, st.size, callback);
        });
        return;
      }
      writeAll(self, handle, buffer, 0, buffer.length, position, callback);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SSH2Stream" id="apidoc.module.ssh2-streams.SSH2Stream">module ssh2-streams.SSH2Stream</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.SSH2Stream" id="apidoc.element.ssh2-streams.SSH2Stream.SSH2Stream">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>SSH2Stream
        <span class="apidocSignatureSpan">(cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SSH2Stream(cfg) {
  if (typeof cfg !== 'object' || cfg === null)
    cfg = {};

  TransformStream.call(this, {
    highWaterMark: (typeof cfg.highWaterMark === 'number'
                    ? cfg.highWaterMark
                    : 32 * 1024)
  });

  this._needContinue = false;
  this.bytesSent = this.bytesReceived = 0;
  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);
  this.server = (cfg.server === true);
  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'
                        ? cfg.maxPacketSize
                        : MAX_PACKET_SIZE);
  // Bitmap that indicates any bugs the remote side has. This is determined
  // by the reported software version.
  this.remoteBugs = 0;

  if (this.server) {
    // TODO: Remove when we support group exchange for server implementation
    this.remoteBugs = BUGS.BAD_DHGEX;
  }

  var self = this;

  var hostKeys = cfg.hostKeys;
  if (this.server &amp;&amp; (typeof hostKeys !== 'object' || hostKeys === null))
    throw new Error('hostKeys must be an object keyed on host key type');

  this.config = {
    // Server
    hostKeys: hostKeys, // All keys supported by server

    // Client/Server
    ident: 'SSH-2.0-'
           + (cfg.ident
              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),
    algorithms: {
      kex: ALGORITHMS.KEX,
      kexBuf: ALGORITHMS.KEX_BUF,
      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,
      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,
      cipher: ALGORITHMS.CIPHER,
      cipherBuf: ALGORITHMS.CIPHER_BUF,
      hmac: ALGORITHMS.HMAC,
      hmacBuf: ALGORITHMS.HMAC_BUF,
      compress: ALGORITHMS.COMPRESS,
      compressBuf: ALGORITHMS.COMPRESS_BUF
    }
  };
  // RFC 4253 states the identification string must not contain NULL
  this.config.ident.replace(RE_NULL, '');

  if (this.config.ident.length + 2 /* Account for "\r\n" */ &gt; 255)
    throw new Error('ident too long');

  if (typeof cfg.algorithms === 'object' &amp;&amp; cfg.algorithms !== null) {
    var algos = cfg.algorithms;
    if (Array.isArray(algos.kex) &amp;&amp; algos.kex.length &gt; 0) {
      this.config.algorithms.kex = algos.kex;
      if (!Buffer.isBuffer(algos.kexBuf))
        algos.kexBuf = new Buffer(algos.kex.join(','), 'ascii');
      this.config.algorithms.kexBuf = algos.kexBuf;
    }
    if (Array.isArray(algos.serverHostKey) &amp;&amp; algos.serverHostKey.length &gt; 0) {
      this.config.algorithms.serverHostKey = algos.serverHostKey;
      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {
        algos.serverHostKeyBuf = new Buffer(algos.serverHostKey.join(','),
                                            'ascii');
      }
      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;
    }
    if (Array.isArray(algos.cipher) &amp;&amp; algos.cipher.length &gt; 0) {
      this.config.algorithms.cipher = algos.cipher;
      if (!Buffer.isBuffer(algos.cipherBuf))
        algos.cipherBuf = new Buffer(algos.cipher.join(','), 'ascii');
      this.config.algorithms.cipherBuf = algos.cipherBuf;
    }
    if (Array.isArray(algos.hmac) &amp;&amp; algos.hmac.length &gt; 0) {
      this.config.algorithms.hmac = algos.hmac;
      if (!Buffer.isBuffer(algos.hmacBuf))
        algos.hmacBuf = new Buffer(algos.hmac.join(','), 'ascii');
      this.config.algorithms.hmacBuf = algos.hmacBuf;
    }
    if (Array.isArray(algos.compress) &amp;&amp; algos.compress.length &gt; 0) {
      this.config.algorithms.compress = algos.compress;
      if (!Buffer.isBuffer(algos.compressBuf))
        algos.compressBuf = new Buffer(algos.compress.join(','), 'ascii');
      this.config.algorithms.compressBuf = algos.compressBuf;
    }
  }

  this.reset(true);

  // Common events
  this.on('end', function() {
    // Let GC collect any Buffers we were previously storing
    self._state = undefined;
    self.reset();
    self._state.incoming.hmac.bufCompute = undefined;
    self._state.outgoing.bufSeqno = undefined;
  });
  this.on('DISCONNECT', function(reason, code, desc, lang) {
    onDISCONNECT(self, reason, code, desc, lang);
  });
  this.on('KEXINIT', function(init, firstFollows) {
    onKEXINIT(self, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream._send" id="apidoc.element.ssh2-streams.SSH2Stream._send">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.</span>_send
        <span class="apidocSignatureSpan">(self, payload, cb, bypass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(self, payload, cb, bypass) {
  var state = self._state;

  if (!state)
    return false;

  var outstate = state.outgoing;
  if (outstate.status === OUT_REKEYING &amp;&amp; !bypass) {
    if (typeof cb === 'function')
      outstate.rekeyQueue.push([payload, cb]);
    else
      outstate.rekeyQueue.push(payload);
    return false;
  } else if (self._readableState.ended || self._writableState.ended)
    return false;

  var compress = outstate.compress.instance;
  if (compress) {
    compress.write(payload);
    compress.flush(Z_PARTIAL_FLUSH, function() {
      if (self._readableState.ended || self._writableState.ended)
        return;
      send_(self, compress.read(), cb);
    });
    return true;
  } else
    return send_(self, payload, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.super_" id="apidoc.element.ssh2-streams.SSH2Stream.super_">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.SSH2Stream.prototype" id="apidoc.module.ssh2-streams.SSH2Stream.prototype">module ssh2-streams.SSH2Stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.__push" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.__push">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>__push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.__read" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.__read">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>__read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._cleanup" id="apidoc.element.ssh2-streams.SSH2Stream.prototype._cleanup">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_cleanup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanup = function (callback) {
  this.reset();
  this.debug('DEBUG: Parser: Malformed packet');
  callback &amp;&amp; callback(new Error('Malformed packet'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._read" id="apidoc.element.ssh2-streams.SSH2Stream.prototype._read">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  if (this._needContinue) {
    this._needContinue = false;
    this.emit('continue');
  }
  return this.__read(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype._transform" id="apidoc.element.ssh2-streams.SSH2Stream.prototype._transform">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback, decomp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback, decomp) {
  var skipDecrypt = false;
  var doDecryptGCM = false;
  var state = this._state;
  var instate = state.incoming;
  var outstate = state.outgoing;
  var expect = instate.expect;
  var decrypt = instate.decrypt;
  var decompress = instate.decompress;
  var chlen = chunk.length;
  var chleft = 0;
  var debug = this.debug;
  var self = this;
  var i = 0;
  var p = i;
  var buffer;
  var buf;
  var r;

  this.bytesReceived += chlen;

  while (true) {
    if (expect.type !== undefined) {
      if (i &gt;= chlen)
        break;
      if (expect.type === EXP_TYPE_BYTES) {
        chleft = (chlen - i);
        var pktLeft = (expect.buf.length - expect.ptr);
        if (pktLeft &lt;= chleft) {
          chunk.copy(expect.buf, expect.ptr, i, i + pktLeft);
          i += pktLeft;
          buffer = expect.buf;
          expect.buf = undefined;
          expect.ptr = 0;
          expect.type = undefined;
        } else {
          chunk.copy(expect.buf, expect.ptr, i);
          expect.ptr += chleft;
          i += chleft;
        }
        continue;
      } else if (expect.type === EXP_TYPE_HEADER) {
        i += instate.search.push(chunk);
        if (expect.type !== undefined)
          continue;
      } else if (expect.type === EXP_TYPE_LF) {
        if (++expect.ptr + 4 /* Account for "SSH-" */ &gt; 255) {
          this.reset();
          debug('DEBUG: Parser: Identification string exceeded 255 characters');
          return callback(new Error('Max identification string size exceeded'));
        }
        if (chunk[i] === 0x0A) {
          expect.type = undefined;
          if (p &lt; i) {
            if (expect.buf === undefined)
              expect.buf = chunk.toString('ascii', p, i);
            else
              expect.buf += chunk.toString('ascii', p, i);
          }
          buffer = expect.buf;
          expect.buf = undefined;
          ++i;
        } else {
          if (++i === chlen &amp;&amp; p &lt; i) {
            if (expect.buf === undefined)
              expect.buf = chunk.toString('ascii', p, i);
            else
              expect.buf += chunk.toString('ascii', p, i);
          }
          continue;
        }
      }
    }

    if (instate.status === IN_INIT) {
      if (this.server) {
        // Retrieve what should be the start of the protocol version exchange
        if (!buffer) {
          debug('DEBUG: Parser: IN_INIT (waiting for identification begin)');
          expectData(this, EXP_TYPE_BYTES, 4);
        } else {
          if (buffer[0] === 0x53       // S
              &amp;&amp; buffer[1] === 0x53    // S
              &amp;&amp; buffer[2] === 0x48    // H
              &amp;&amp; buffer[3] === 0x2D) { // -
            instate.status = IN_GREETING;
            debug('DEBUG: Parser: IN_INIT (waiting for rest of identification)');
          } else {
            this.reset();
            debug('DEBUG: Parser: Bad identification start');
            return callback(new Error('Bad identification start'));
          }
        }
      } else {
        debug('DEBUG: Parser: IN_INIT');
        // Retrieve any bytes that may come before the protocol version exchange
        var ss = instate.search = new StreamSearch(IDENT_PREFIX_BUFFER);
        ss.on('info', function onInfo(matched, data, start, end) {
          if (data) {
            if (instate.greeting === undefined)
              instate.greeting = data.toString('binary', start, end);
            else
              instate.greeting += data.toString('binary', start, end);
          }
          if (matched) {
            expect.type = undefined;
            instate.search.removeListener('info', onInfo);
          }
        });
        ss.maxMatches = 1;
        expectData(this, EXP_TYPE_HEADER);
        instate.status = IN_GREETING;
      }
    } else if (instate.status === IN_GREETING) {
      debug('DEBUG: Parser: IN_GREETING');
      instate.search = undefined;
      // Retrieve the identification bytes after the "SSH-" header
      p = i;
      expectData(this, EXP_TYPE_LF);
      instate.status = IN_HEADER;
    } else if (instate.status === ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authFailure" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authFailure">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authFailure
        <span class="apidocSignatureSpan">(authMethods, isPartial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authFailure = function (authMethods, isPartial) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var authsQueue = this._state.authsQueue;
  if (!authsQueue.length)
    throw new Error('No auth in progress');

  var methods;

  if (typeof authMethods === 'boolean') {
    isPartial = authMethods;
    authMethods = undefined;
  }

  if (authMethods) {
    methods = [];
    for (var i = 0, len = authMethods.length; i &lt; len; ++i) {
      if (authMethods[i].toLowerCase() === 'none')
        continue;
      methods.push(authMethods[i]);
    }
    methods = methods.join(',');
  } else
    methods = '';

  var methodsLen = methods.length;
  var buf = new Buffer(1 + 4 + methodsLen + 1);

  buf[0] = MESSAGE.USERAUTH_FAILURE;

  buf.writeUInt32BE(methodsLen, 1, true);
  buf.write(methods, 5, methodsLen, 'ascii');

  buf[5 + methodsLen] = (isPartial === true ? 1 : 0);

  this._state.authsQueue.shift();
  this.debug('DEBUG: Outgoing: Writing USERAUTH_FAILURE');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authHostbased" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authHostbased">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authHostbased
        <span class="apidocSignatureSpan">(username, pubKey, hostname, userlocal, cbSign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authHostbased = function (username, pubKey, hostname, userlocal, cbSign) {
  // TODO: Make DRY by sharing similar code with authPK()

  if (this.server)
    throw new Error('Client-only method called in server mode');

  var self = this;
  var outstate = this._state.outgoing;
  var pubKeyFullType;

  if (pubKey.public) {
    pubKeyFullType = pubKey.fulltype;
    pubKey = pubKey.public;
  } else {
    pubKeyFullType = pubKey.toString('ascii',
                                     4,
                                     4 + pubKey.readUInt32BE(0, true));
  }

  var userLen = Buffer.byteLength(username);
  var algoLen = Buffer.byteLength(pubKeyFullType);
  var pubKeyLen = pubKey.length;
  var sesLen = outstate.sessionId.length;
  var hostnameLen = Buffer.byteLength(hostname);
  var userlocalLen = Buffer.byteLength(userlocal);
  var p = 0;
  var buf = new Buffer(4 + sesLen
                       + 1
                       + 4 + userLen
                       + 4 + 14 // "ssh-connection"
                       + 4 + 9 // "hostbased"
                       + 4 + algoLen
                       + 4 + pubKeyLen
                       + 4 + hostnameLen
                       + 4 + userlocalLen
                      );

  buf.writeUInt32BE(sesLen, p, true);
  outstate.sessionId.copy(buf, p += 4);

  buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;

  buf.writeUInt32BE(userLen, ++p, true);
  buf.write(username, p += 4, userLen, 'utf8');

  buf.writeUInt32BE(14, p += userLen, true);
  buf.write('ssh-connection', p += 4, 14, 'ascii');

  buf.writeUInt32BE(9, p += 14, true);
  buf.write('hostbased', p += 4, 9, 'ascii');

  buf.writeUInt32BE(algoLen, p += 9, true);
  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');

  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);
  pubKey.copy(buf, p += 4);

  buf.writeUInt32BE(hostnameLen, p += pubKeyLen, true);
  buf.write(hostname, p += 4, hostnameLen, 'ascii');

  buf.writeUInt32BE(userlocalLen, p += hostnameLen, true);
  buf.write(userlocal, p += 4, userlocalLen, 'utf8');

  cbSign(buf, function(signature) {
    if (pubKeyFullType === 'ssh-dss') {
      signature = DSASigBERToBare(signature);
    } else if (pubKeyFullType !== 'ssh-rsa') {
      // ECDSA
      signature = ECDSASigASN1ToSSH(signature);
    }
    var sigLen = signature.length;
    var sigbuf = new Buffer((buf.length - sesLen) + sigLen);

    buf.copy(sigbuf, 0, 4 + sesLen);
    sigbuf.writeUInt32BE(sigLen, sigbuf.length - sigLen - 4, true);
    signature.copy(sigbuf, sigbuf.length - sigLen);

    self._state.authsQueue.push('hostbased');
    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (hostbased)');
    return send(self, sigbuf);
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoReq" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoReq">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authInfoReq
        <span class="apidocSignatureSpan">(name, instructions, prompts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authInfoReq = function (name, instructions, prompts) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var promptsLen = 0;
  var nameLen = name ? Buffer.byteLength(name) : 0;
  var instrLen = instructions ? Buffer.byteLength(instructions) : 0;
  var p = 0;
  var promptLen;
  var prompt;
  var len;
  var i;

  for (i = 0, len = prompts.length; i &lt; len; ++i)
    promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
  var buf = new Buffer(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);

  buf[p++] = MESSAGE.USERAUTH_INFO_REQUEST;

  buf.writeUInt32BE(nameLen, p, true);
  p += 4;
  if (name) {
    buf.write(name, p, nameLen, 'utf8');
    p += nameLen;
  }

  buf.writeUInt32BE(instrLen, p, true);
  p += 4;
  if (instructions) {
    buf.write(instructions, p, instrLen, 'utf8');
    p += instrLen;
  }

  buf.writeUInt32BE(0, p, true);
  p += 4;

  buf.writeUInt32BE(prompts.length, p, true);
  p += 4;
  for (i = 0, len = prompts.length; i &lt; len; ++i) {
    prompt = prompts[i];
    promptLen = Buffer.byteLength(prompt.prompt);
    buf.writeUInt32BE(promptLen, p, true);
    p += 4;
    if (promptLen) {
      buf.write(prompt.prompt, p, promptLen, 'utf8');
      p += promptLen;
    }
    buf[p++] = (prompt.echo ? 1 : 0);
  }

  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_REQUEST');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoRes" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authInfoRes">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authInfoRes
        <span class="apidocSignatureSpan">(responses)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authInfoRes = function (responses) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var responsesLen = 0;
  var p = 0;
  var resLen;
  var len;
  var i;

  if (responses) {
    for (i = 0, len = responses.length; i &lt; len; ++i)
      responsesLen += 4 + Buffer.byteLength(responses[i]);
  }
  var buf = new Buffer(1 + 4 + responsesLen);

  buf[p++] = MESSAGE.USERAUTH_INFO_RESPONSE;

  buf.writeUInt32BE(responses ? responses.length : 0, p, true);
  if (responses) {
    p += 4;
    for (i = 0, len = responses.length; i &lt; len; ++i) {
      resLen = Buffer.byteLength(responses[i]);
      buf.writeUInt32BE(resLen, p, true);
      p += 4;
      if (resLen) {
        buf.write(responses[i], p, resLen, 'utf8');
        p += resLen;
      }
    }
  }

  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_RESPONSE');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authKeyboard" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authKeyboard">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authKeyboard
        <span class="apidocSignatureSpan">(username)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authKeyboard = function (username) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var userLen = Buffer.byteLength(username);
  var p = 0;
  var buf = new Buffer(1
                       + 4 + userLen
                       + 4 + 14 // "ssh-connection"
                       + 4 + 20 // "keyboard-interactive"
                       + 4 // no language set
                       + 4 // no submethods
                      );

  buf[p] = MESSAGE.USERAUTH_REQUEST;

  buf.writeUInt32BE(userLen, ++p, true);
  buf.write(username, p += 4, userLen, 'utf8');

  buf.writeUInt32BE(14, p += userLen, true);
  buf.write('ssh-connection', p += 4, 14, 'ascii');

  buf.writeUInt32BE(20, p += 14, true);
  buf.write('keyboard-interactive', p += 4, 20, 'ascii');

  buf.writeUInt32BE(0, p += 20, true);

  buf.writeUInt32BE(0, p += 4, true);

  this._state.authsQueue.push('keyboard-interactive');
  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (keyboard-interactive)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authNone" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authNone">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authNone
        <span class="apidocSignatureSpan">(username)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authNone = function (username) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var userLen = Buffer.byteLength(username);
  var p = 0;
  var buf = new Buffer(1
                       + 4 + userLen
                       + 4 + 14 // "ssh-connection"
                       + 4 + 4 // "none"
                      );

  buf[p] = MESSAGE.USERAUTH_REQUEST;

  buf.writeUInt32BE(userLen, ++p, true);
  buf.write(username, p += 4, userLen, 'utf8');

  buf.writeUInt32BE(14, p += userLen, true);
  buf.write('ssh-connection', p += 4, 14, 'ascii');

  buf.writeUInt32BE(4, p += 14, true);
  buf.write('none', p += 4, 4, 'ascii');

  this._state.authsQueue.push('none');
  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (none)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPK" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authPK">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPK
        <span class="apidocSignatureSpan">(username, pubKey, cbSign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authPK = function (username, pubKey, cbSign) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var self = this;
  var outstate = this._state.outgoing;
  var pubKeyFullType;

  if (pubKey.public) {
    pubKeyFullType = pubKey.fulltype;
    pubKey = pubKey.public;
  } else {
    pubKeyFullType = pubKey.toString('ascii',
                                     4,
                                     4 + pubKey.readUInt32BE(0, true));
  }

  var userLen = Buffer.byteLength(username);
  var algoLen = Buffer.byteLength(pubKeyFullType);
  var pubKeyLen = pubKey.length;
  var sesLen = outstate.sessionId.length;
  var p = 0;
  var buf = new Buffer((cbSign ? 4 + sesLen : 0)
                       + 1
                       + 4 + userLen
                       + 4 + 14 // "ssh-connection"
                       + 4 + 9 // "publickey"
                       + 1
                       + 4 + algoLen
                       + 4 + pubKeyLen
                      );

  if (cbSign) {
    buf.writeUInt32BE(sesLen, p, true);
    outstate.sessionId.copy(buf, p += 4);
    buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
  } else
    buf[p] = MESSAGE.USERAUTH_REQUEST;

  buf.writeUInt32BE(userLen, ++p, true);
  buf.write(username, p += 4, userLen, 'utf8');

  buf.writeUInt32BE(14, p += userLen, true);
  buf.write('ssh-connection', p += 4, 14, 'ascii');

  buf.writeUInt32BE(9, p += 14, true);
  buf.write('publickey', p += 4, 9, 'ascii');

  buf[p += 9] = (cbSign ? 1 : 0);

  buf.writeUInt32BE(algoLen, ++p, true);
  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');

  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);
  pubKey.copy(buf, p += 4);

  if (!cbSign) {
    this._state.authsQueue.push('publickey');
    this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey -- check)');
    return send(this, buf);
  }

  cbSign(buf, function(signature) {
    if (pubKeyFullType === 'ssh-dss') {
      signature = DSASigBERToBare(signature);
    } else if (pubKeyFullType !== 'ssh-rsa') {
      // ECDSA
      signature = ECDSASigASN1ToSSH(signature);
    }

    var sigLen = signature.length;
    var sigbuf = new Buffer(1
                            + 4 + userLen
                            + 4 + 14 // "ssh-connection"
                            + 4 + 9 // "publickey"
                            + 1
                            + 4 + algoLen
                            + 4 + pubKeyLen
                            + 4 // 4 + algoLen + 4 + sigLen
                            + 4 + algoLen
                            + 4 + sigLen);

    p = 0;

    sigbuf[p] = MESSAGE.USERAUTH_REQUEST;

    sigbuf.writeUInt32BE(userLen, ++p, true);
    sigbuf.write(username, p += 4, userLen, 'utf8');

    sigbuf.writeUInt32BE(14, p += userLen, true);
    sigbuf.write('ssh-connection', p += 4, 14, 'ascii');

    sigbuf.writeUInt32BE(9, p += 14, true);
    sigbuf.write('publickey', p += 4, 9, 'ascii');

    sigbuf[p += 9] = 1;

    sigbuf.writeUInt32BE(algoLen, ++p, true);
    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');

    sigbuf.writeUInt32BE(pubKeyLen, p += algoLen, true);
    pubKey.copy(sigbuf, p += 4);
    sigbuf.writeUInt32BE(4 + algoLen + 4 + sigLen, p += pubKeyLen, true);
    sigbuf.writeUInt32BE(algoLen, p += 4, true);
    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');
    sigbuf.writeUInt32BE(sigLen, p += algoLen, true);
    signature.copy(sigbuf, p += 4);

    // Servers shouldn't send packet type 60 in response to signed publickey
    // attempts, but if they do, interpret as type 60.
    self._state.authsQueue.push('publickey');
    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey)');
    return send(self, sigbuf);
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPKOK" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authPKOK">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPKOK
        <span class="apidocSignatureSpan">(keyAlgo, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authPKOK = function (keyAlgo, key) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var authsQueue = this._state.authsQueue;
  if (!authsQueue.length || authsQueue[0] !== 'publickey')
    throw new Error('"publickey" auth not in progress');

  var keyAlgoLen = keyAlgo.length;
  var keyLen = key.length;
  var buf = new Buffer(1 + 4 + keyAlgoLen + 4 + keyLen);

  buf[0] = MESSAGE.USERAUTH_PK_OK;

  buf.writeUInt32BE(keyAlgoLen, 1, true);
  buf.write(keyAlgo, 5, keyAlgoLen, 'ascii');

  buf.writeUInt32BE(keyLen, 5 + keyAlgoLen, true);
  key.copy(buf, 5 + keyAlgoLen + 4);

  this._state.authsQueue.shift();
  this.debug('DEBUG: Outgoing: Writing USERAUTH_PK_OK');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPasswdChg" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authPasswdChg">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPasswdChg
        <span class="apidocSignatureSpan">(prompt, lang)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authPasswdChg = function (prompt, lang) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var promptLen = Buffer.byteLength(prompt);
  var langLen = lang ? lang.length : 0;
  var p = 0;
  var buf = new Buffer(1 + 4 + promptLen + 4 + langLen);

  buf[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;

  buf.writeUInt32BE(promptLen, ++p, true);
  buf.write(prompt, p += 4, promptLen, 'utf8');

  buf.writeUInt32BE(langLen, p += promptLen, true);
  if (langLen)
    buf.write(lang, p += 4, langLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing USERAUTH_PASSWD_CHANGEREQ');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authPassword" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authPassword">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authPassword
        <span class="apidocSignatureSpan">(username, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authPassword = function (username, password) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var userLen = Buffer.byteLength(username);
  var passLen = Buffer.byteLength(password);
  var p = 0;
  var buf = new Buffer(1
                       + 4 + userLen
                       + 4 + 14 // "ssh-connection"
                       + 4 + 8 // "password"
                       + 1
                       + 4 + passLen);

  buf[p] = MESSAGE.USERAUTH_REQUEST;

  buf.writeUInt32BE(userLen, ++p, true);
  buf.write(username, p += 4, userLen, 'utf8');

  buf.writeUInt32BE(14, p += userLen, true);
  buf.write('ssh-connection', p += 4, 14, 'ascii');

  buf.writeUInt32BE(8, p += 14, true);
  buf.write('password', p += 4, 8, 'ascii');

  buf[p += 8] = 0;

  buf.writeUInt32BE(passLen, ++p, true);
  buf.write(password, p += 4, passLen, 'utf8');

  this._state.authsQueue.push('password');
  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (password)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.authSuccess" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.authSuccess">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>authSuccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authSuccess = function () {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var authsQueue = this._state.authsQueue;
  if (!authsQueue.length)
    throw new Error('No auth in progress');

  this._state.authsQueue.shift();
  this.debug('DEBUG: Outgoing: Writing USERAUTH_SUCCESS');
  return send(this, USERAUTH_SUCCESS_PACKET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.cancelTcpipForward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.cancelTcpipForward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>cancelTcpipForward
        <span class="apidocSignatureSpan">(bindAddr, bindPort, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancelTcpipForward = function (bindAddr, bindPort, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var addrlen = Buffer.byteLength(bindAddr);
  var buf = new Buffer(1 + 4 + 20 + 1 + 4 + addrlen + 4);

  buf[0] = MESSAGE.GLOBAL_REQUEST;

  buf.writeUInt32BE(20, 1, true);
  buf.write('cancel-tcpip-forward', 5, 20, 'ascii');

  buf[25] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(addrlen, 26, true);
  buf.write(bindAddr, 30, addrlen, 'ascii');

  buf.writeUInt32BE(bindPort, 30 + addrlen, true);

  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-tcpip-forward)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelClose" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelClose">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelClose
        <span class="apidocSignatureSpan">(chan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelClose = function (chan) {
  // Does not consume window space
  var buf = new Buffer(1 + 4);

  buf[0] = MESSAGE.CHANNEL_CLOSE;

  buf.writeUInt32BE(chan, 1, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_CLOSE (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelData" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelData">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelData
        <span class="apidocSignatureSpan">(chan, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelData = function (chan, data) {
  var dataIsBuffer = Buffer.isBuffer(data);
  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));
  var buf = new Buffer(1 + 4 + 4 + dataLen);

  buf[0] = MESSAGE.CHANNEL_DATA;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(dataLen, 5, true);
  if (dataIsBuffer)
    data.copy(buf, 9);
  else
    buf.write(data, 9, dataLen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_DATA (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelEOF" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelEOF">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelEOF
        <span class="apidocSignatureSpan">(chan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelEOF = function (chan) {
  // Does not consume window space
  var buf = new Buffer(1 + 4);

  buf[0] = MESSAGE.CHANNEL_EOF;

  buf.writeUInt32BE(chan, 1, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_EOF (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelExtData" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelExtData">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelExtData
        <span class="apidocSignatureSpan">(chan, data, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelExtData = function (chan, data, type) {
  var dataIsBuffer = Buffer.isBuffer(data);
  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));
  var buf = new Buffer(1 + 4 + 4 + 4 + dataLen);

  buf[0] = MESSAGE.CHANNEL_EXTENDED_DATA;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(type, 5, true);

  buf.writeUInt32BE(dataLen, 9, true);
  if (dataIsBuffer)
    data.copy(buf, 13);
  else
    buf.write(data, 13, dataLen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_EXTENDED_DATA (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelFailure" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelFailure">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelFailure
        <span class="apidocSignatureSpan">(chan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelFailure = function (chan) {
  // Does not consume window space
  var buf = new Buffer(1 + 4);

  buf[0] = MESSAGE.CHANNEL_FAILURE;

  buf.writeUInt32BE(chan, 1, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_FAILURE (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenConfirm" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenConfirm">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelOpenConfirm
        <span class="apidocSignatureSpan">(remoteChan, localChan, initWindow, maxPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelOpenConfirm = function (remoteChan, localChan, initWindow, maxPacket) {
  var buf = new Buffer(1 + 4 + 4 + 4 + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;

  buf.writeUInt32BE(remoteChan, 1, true);

  buf.writeUInt32BE(localChan, 5, true);

  buf.writeUInt32BE(initWindow, 9, true);

  buf.writeUInt32BE(maxPacket, 13, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_CONFIRMATION (r:'
             + remoteChan
             + ', l:'
             + localChan
             + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenFail" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelOpenFail">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelOpenFail
        <span class="apidocSignatureSpan">(remoteChan, reason, desc, lang)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelOpenFail = function (remoteChan, reason, desc, lang) {
  if (typeof desc !== 'string')
    desc = '';
  if (typeof lang !== 'string')
    lang = '';

  var descLen = Buffer.byteLength(desc);
  var langLen = Buffer.byteLength(lang);
  var p = 9;
  var buf = new Buffer(1 + 4 + 4 + 4 + descLen + 4 + langLen);

  buf[0] = MESSAGE.CHANNEL_OPEN_FAILURE;

  buf.writeUInt32BE(remoteChan, 1, true);

  buf.writeUInt32BE(reason, 5, true);

  buf.writeUInt32BE(descLen, p, true);
  p += 4;
  if (descLen) {
    buf.write(desc, p, descLen, 'utf8');
    p += descLen;
  }

  buf.writeUInt32BE(langLen, p, true);
  if (langLen)
    buf.write(lang, p += 4, langLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_FAILURE ('
             + remoteChan
             + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelSuccess" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelSuccess">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelSuccess
        <span class="apidocSignatureSpan">(chan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelSuccess = function (chan) {
  // Does not consume window space
  var buf = new Buffer(1 + 4);

  buf[0] = MESSAGE.CHANNEL_SUCCESS;

  buf.writeUInt32BE(chan, 1, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_SUCCESS (' + chan + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.channelWindowAdjust" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.channelWindowAdjust">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>channelWindowAdjust
        <span class="apidocSignatureSpan">(chan, amount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">channelWindowAdjust = function (chan, amount) {
  // Does not consume window space
  var buf = new Buffer(1 + 4 + 4);

  buf[0] = MESSAGE.CHANNEL_WINDOW_ADJUST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(amount, 5, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_WINDOW_ADJUST ('
             + chan
             + ', '
             + amount
             + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.directTcpip" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.directTcpip">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>directTcpip
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directTcpip = function (chan, initWindow, maxPacket, cfg) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var srclen = Buffer.byteLength(cfg.srcIP);
  var dstlen = Buffer.byteLength(cfg.dstIP);
  var p = 29;
  var buf = new Buffer(1 + 4 + 12 + 4 + 4 + 4 + 4 + srclen + 4 + 4 + dstlen
                       + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(12, 1, true);
  buf.write('direct-tcpip', 5, 12, 'ascii');

  buf.writeUInt32BE(chan, 17, true);

  buf.writeUInt32BE(initWindow, 21, true);

  buf.writeUInt32BE(maxPacket, 25, true);

  buf.writeUInt32BE(dstlen, p, true);
  buf.write(cfg.dstIP, p += 4, dstlen, 'ascii');

  buf.writeUInt32BE(cfg.dstPort, p += dstlen, true);

  buf.writeUInt32BE(srclen, p += 4, true);
  buf.write(cfg.srcIP, p += 4, srclen, 'ascii');

  buf.writeUInt32BE(cfg.srcPort, p += srclen, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', direct-tcpip)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.disconnect" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.disconnect">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (reason) {
<span class="apidocCodeCommentSpan">  /*
    byte      SSH_MSG_DISCONNECT
    uint32    reason code
    string    description in ISO-10646 UTF-8 encoding
    string    language tag
  */
</span>  var buf = new Buffer(1 + 4 + 4 + 4);

  buf.fill(0);
  buf[0] = MESSAGE.DISCONNECT;

  if (DISCONNECT_REASON[reason] === undefined)
    reason = DISCONNECT_REASON.BY_APPLICATION;
  buf.writeUInt32BE(reason, 1, true);

  this.debug('DEBUG: Outgoing: Writing DISCONNECT ('
             + DISCONNECT_REASON[reason]
             + ')');
  send(this, buf);
  this.reset();

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.env" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.env">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>env
        <span class="apidocSignatureSpan">(chan, key, val, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">env = function (chan, key, val, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var keyLen = Buffer.byteLength(key);
  var valLen = (Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val));
  var buf = new Buffer(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(3, 5, true);
  buf.write('env', 9, 3, 'ascii');

  buf[12] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(keyLen, 13, true);
  buf.write(key, 17, keyLen, 'ascii');

  buf.writeUInt32BE(valLen, 17 + keyLen, true);
  if (Buffer.isBuffer(val))
    val.copy(buf, 17 + keyLen + 4);
  else
    buf.write(val, 17 + keyLen + 4, valLen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', env)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exec" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.exec">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exec
        <span class="apidocSignatureSpan">(chan, cmd, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (chan, cmd, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var cmdlen = (Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd));
  var buf = new Buffer(1 + 4 + 4 + 4 + 1 + 4 + cmdlen);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(4, 5, true);
  buf.write('exec', 9, 4, 'ascii');

  buf[13] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(cmdlen, 14, true);
  if (Buffer.isBuffer(cmd))
    cmd.copy(buf, 18);
  else
    buf.write(cmd, 18, cmdlen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', exec)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  while (!data[0].length)
data.shift();
  while (!data.slice(-1)[0].length)
data.pop();

  var orig = data.join('\n');

  if ((m = RE_HEADER_OPENSSH_PRIV.<span class="apidocCodeKeywordSpan">exec</span>(data[0]))
  &amp;&amp; RE_FOOTER_OPENSSH_PRIV.test(data.slice(-1))) {
// OpenSSH private key
var keyType = m[1].toLowerCase();
if (keyType === 'dsa')
  keyType = 'dss';

if (keyType === 'ec' &amp;&amp; semver.lt(process.version, '5.2.0')) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exitSignal" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.exitSignal">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exitSignal
        <span class="apidocSignatureSpan">(chan, name, coreDumped, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitSignal = function (chan, name, coreDumped, msg) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  // Does not consume window space
  var nameLen = Buffer.byteLength(name);
  var msgLen = (msg ? Buffer.byteLength(msg) : 0);
  var p = 25 + nameLen;
  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(11, 5, true);
  buf.write('exit-signal', 9, 11, 'ascii');

  buf[20] = 0;

  buf.writeUInt32BE(nameLen, 21, true);
  buf.write(name, 25, nameLen, 'utf8');

  buf[p++] = (coreDumped ? 1 : 0);

  buf.writeUInt32BE(msgLen, p, true);
  p += 4;
  if (msgLen) {
    buf.write(msg, p, msgLen, 'utf8');
    p += msgLen;
  }

  buf.writeUInt32BE(0, p, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', exit-signal)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.exitStatus" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.exitStatus">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>exitStatus
        <span class="apidocSignatureSpan">(chan, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitStatus = function (chan, status) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  // Does not consume window space
  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(11, 5, true);
  buf.write('exit-status', 9, 11, 'ascii');

  buf[20] = 0;

  buf.writeUInt32BE(status, 21, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', exit-status)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.forwardedTcpip" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.forwardedTcpip">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>forwardedTcpip
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardedTcpip = function (chan, initWindow, maxPacket, cfg) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var boundAddrLen = Buffer.byteLength(cfg.boundAddr);
  var remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
  var p = 36 + boundAddrLen;
  var buf = new Buffer(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4
                       + remoteAddrLen + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(15, 1, true);
  buf.write('forwarded-tcpip', 5, 15, 'ascii');

  buf.writeUInt32BE(chan, 20, true);

  buf.writeUInt32BE(initWindow, 24, true);

  buf.writeUInt32BE(maxPacket, 28, true);

  buf.writeUInt32BE(boundAddrLen, 32, true);
  buf.write(cfg.boundAddr, 36, boundAddrLen, 'ascii');

  buf.writeUInt32BE(cfg.boundPort, p, true);

  buf.writeUInt32BE(remoteAddrLen, p += 4, true);
  buf.write(cfg.remoteAddr, p += 4, remoteAddrLen, 'ascii');

  buf.writeUInt32BE(cfg.remotePort, p += remoteAddrLen, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', forwarded-tcpip)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_agentForward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_agentForward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_agentForward
        <span class="apidocSignatureSpan">(chan, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_agentForward = function (chan, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var buf = new Buffer(1 + 4 + 4 + 26 + 1);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(26, 5, true);
  buf.write('auth-agent-req@openssh.com', 9, 26, 'ascii');

  buf[35] = (wantReply === undefined || wantReply === true ? 1 : 0);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', auth-agent-req@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_cancelStreamLocalForward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_cancelStreamLocalForward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_cancelStreamLocalForward
        <span class="apidocSignatureSpan">(socketPath, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_cancelStreamLocalForward = function (socketPath, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var pathlen = Buffer.byteLength(pathlen);
  var buf = new Buffer(1 + 4 + 38 + 1 + 4 + pathlen);

  buf[0] = MESSAGE.GLOBAL_REQUEST;

  buf.writeUInt32BE(38, 1, true);
  buf.write('cancel-streamlocal-forward@openssh.com', 5, 38, 'ascii');

  buf[43] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(pathlen, 44, true);
  buf.write(socketPath, 48, pathlen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_directStreamLocal" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_directStreamLocal">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_directStreamLocal
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_directStreamLocal = function (chan, initWindow, maxPacket, cfg) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var pathlen = Buffer.byteLength(cfg.socketPath);
  var p = 47;
  var buf = new Buffer(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathlen + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(30, 1, true);
  buf.write('direct-streamlocal@openssh.com', 5, 30, 'ascii');

  buf.writeUInt32BE(chan, 35, true);

  buf.writeUInt32BE(initWindow, 39, true);

  buf.writeUInt32BE(maxPacket, 43, true);

  buf.writeUInt32BE(pathlen, p, true);
  buf.write(cfg.socketPath, p += 4, pathlen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', direct-streamlocal@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_forwardedStreamLocal" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_forwardedStreamLocal">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_forwardedStreamLocal
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_forwardedStreamLocal = function (chan, initWindow, maxPacket, cfg) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var pathlen = Buffer.byteLength(cfg.socketPath);
  var buf = new Buffer(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathlen + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(33, 1, true);
  buf.write('forwarded-streamlocal@openssh.com', 5, 33, 'ascii');

  buf.writeUInt32BE(chan, 38, true);

  buf.writeUInt32BE(initWindow, 42, true);

  buf.writeUInt32BE(maxPacket, 46, true);

  buf.writeUInt32BE(pathlen, 50, true);
  buf.write(cfg.socketPath, 54, pathlen, 'utf8');

  buf.writeUInt32BE(0, 54 + pathlen, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', forwarded-streamlocal@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_noMoreSessions" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_noMoreSessions">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_noMoreSessions
        <span class="apidocSignatureSpan">(wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_noMoreSessions = function (wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var buf = new Buffer(1 + 4 + 28 + 1);

  buf[0] = MESSAGE.GLOBAL_REQUEST;

  buf.writeUInt32BE(28, 1, true);
  buf.write('no-more-sessions@openssh.com', 5, 28, 'ascii');

  buf[33] = (wantReply === undefined || wantReply === true ? 1 : 0);

  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (no-more-sessions@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_streamLocalForward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.openssh_streamLocalForward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>openssh_streamLocalForward
        <span class="apidocSignatureSpan">(socketPath, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openssh_streamLocalForward = function (socketPath, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var pathlen = Buffer.byteLength(pathlen);
  var buf = new Buffer(1 + 4 + 31 + 1 + 4 + pathlen);

  buf[0] = MESSAGE.GLOBAL_REQUEST;

  buf.writeUInt32BE(31, 1, true);
  buf.write('streamlocal-forward@openssh.com', 5, 31, 'ascii');

  buf[36] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(pathlen, 37, true);
  buf.write(socketPath, 41, pathlen, 'utf8');

  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (streamlocal-forward@openssh.com)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.ping" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.ping">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>ping
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function () {
  this.debug('DEBUG: Outgoing: Writing ping (GLOBAL_REQUEST: keepalive@openssh.com)');
  return send(this, PING_PACKET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.pty" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.pty">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>pty
        <span class="apidocSignatureSpan">(chan, rows, cols, height, width, term, modes, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pty = function (chan, rows, cols, height, width, term, modes, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  if (!term || !term.length)
    term = 'vt100';
  if (modes
      &amp;&amp; !Buffer.isBuffer(modes)
      &amp;&amp; !Array.isArray(modes)
      &amp;&amp; typeof modes === 'object')
    modes = modesToBytes(modes);
  if (!modes || !modes.length)
    modes = NO_TERMINAL_MODES_BUFFER;

  var termLen = term.length;
  var modesLen = modes.length;
  var p = 21;
  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4
                       + modesLen);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(7, 5, true);
  buf.write('pty-req', 9, 7, 'ascii');

  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(termLen, 17, true);
  buf.write(term, 21, termLen, 'utf8');

  buf.writeUInt32BE(cols, p += termLen, true);

  buf.writeUInt32BE(rows, p += 4, true);

  buf.writeUInt32BE(width, p += 4, true);

  buf.writeUInt32BE(height, p += 4, true);

  buf.writeUInt32BE(modesLen, p += 4, true);
  p += 4;
  if (Array.isArray(modes)) {
    for (var i = 0; i &lt; modesLen; ++i)
      buf[p++] = modes[i];
  } else if (Buffer.isBuffer(modes)) {
    modes.copy(buf, p);
  }

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', pty-req)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.push" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.push">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk, encoding) {
  var ret = this.__push(chunk, encoding);
  this._needContinue = (ret === false);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var SUPPORTED_SERVER_HOST_KEY = [
  'ssh-dss'
];
if (semver.gte(process.version, '5.2.0')) {
  // ECDSA keys are only supported in v5.2.0+ because of a crypto change that
  // made it possible to (efficiently) generate an ECDSA public key from a
  // private key (commit nodejs/node#da5ac55c83eb2c09cfb3baf7875529e8f1113529)
  DEFAULT_SERVER_HOST_KEY.<span class="apidocCodeKeywordSpan">push</span>(
    'ecdsa-sha2-nistp256',
    'ecdsa-sha2-nistp384',
    'ecdsa-sha2-nistp521'
  );
}
var SERVER_HOST_KEY_BUF = new Buffer(DEFAULT_SERVER_HOST_KEY.join(','),
'ascii');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.rekey" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.rekey">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>rekey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rekey = function () {
  var status = this._state.outgoing.status;
  if (status === OUT_REKEYING)
    throw new Error('A re-key is already in progress');
  else if (status !== OUT_READY)
    throw new Error('Cannot re-key yet');

  this.debug('DEBUG: Outgoing: Starting re-key');
  return KEXINIT(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.requestFailure" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.requestFailure">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>requestFailure
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requestFailure = function () {
  this.debug('DEBUG: Outgoing: Writing REQUEST_FAILURE');
  return send(this, REQUEST_FAILURE_PACKET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.requestSuccess" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.requestSuccess">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>requestSuccess
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requestSuccess = function (data) {
  var buf;
  if (Buffer.isBuffer(data)) {
    buf = new Buffer(1 + data.length);

    buf[0] = MESSAGE.REQUEST_SUCCESS;

    data.copy(buf, 1);
  } else
    buf = REQUEST_SUCCESS_PACKET;

  this.debug('DEBUG: Outgoing: Writing REQUEST_SUCCESS');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.reset" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.reset">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>reset
        <span class="apidocSignatureSpan">(noend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (noend) {
  if (this._state) {
    var state = this._state;
    state.incoming.status = IN_INIT;
    state.outgoing.status = OUT_INIT;
  } else {
    this._state = {
      authsQueue: [],
      hostkeyFormat: undefined,
      kex: undefined,
      kexdh: undefined,

      incoming: {
        status: IN_INIT,
        expectedPacket: undefined,
        search: undefined,
        greeting: undefined,
        seqno: 0,
        pktLen: undefined,
        padLen: undefined,
        pktExtra: undefined,
        payload: undefined,
        packet: undefined,
        kexinit: undefined,
        identRaw: undefined,
        rekeyQueue: [],
        ignoreNext: false,

        expect: {
          amount: undefined,
          type: undefined,
          ptr: 0,
          buf: undefined
        },

        decrypt: {
          instance: false,
          size: 8,
          isGCM: false,
          iv: undefined, // GCM
          key: undefined, // GCM
          buf: undefined,
          type: undefined
        },

        hmac: {
          size: undefined,
          key: undefined,
          buf: undefined,
          bufCompute: new Buffer(9),
          type: false
        },

        decompress: {
          instance: false,
          type: false
        }
      },

      outgoing: {
        status: OUT_INIT,
        seqno: 0,
        bufSeqno: new Buffer(4),
        rekeyQueue: [],
        kexinit: undefined,
        kexsecret: undefined,
        pubkey: undefined,
        exchangeHash: undefined,
        sessionId: undefined,
        sentNEWKEYS: false,

        encrypt: {
          instance: false,
          size: 8,
          isGCM: false,
          iv: undefined, // GCM
          key: undefined, // GCM
          type: undefined
        },

        hmac: {
          size: undefined,
          key: undefined,
          buf: undefined,
          type: false
        },

        compress: {
          instance: false,
          type: false
        }
      }
    };
  }
  if (!noend) {
    if (this.readable)
      this.push(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.service" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.service">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>service
        <span class="apidocSignatureSpan">(svcName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">service = function (svcName) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var svcNameLen = Buffer.byteLength(svcName);
  var buf = new Buffer(1 + 4 + svcNameLen);

  buf[0] = MESSAGE.SERVICE_REQUEST;

  buf.writeUInt32BE(svcNameLen, 1, true);
  buf.write(svcName, 5, svcNameLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing SERVICE_REQUEST (' + svcName + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.serviceAccept" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.serviceAccept">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>serviceAccept
        <span class="apidocSignatureSpan">(svcName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serviceAccept = function (svcName) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var svcNameLen = svcName.length;
  var buf = new Buffer(1 + 4 + svcNameLen);

  buf[0] = MESSAGE.SERVICE_ACCEPT;

  buf.writeUInt32BE(svcNameLen, 1, true);
  buf.write(svcName, 5, svcNameLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing SERVICE_ACCEPT (' + svcName + ')');
  send(this, buf);

  if (this.server &amp;&amp; this.banner &amp;&amp; svcName === 'ssh-userauth') {
<span class="apidocCodeCommentSpan">    /*
      byte      SSH_MSG_USERAUTH_BANNER
      string    message in ISO-10646 UTF-8 encoding
      string    language tag
    */
</span>    var bannerLen = Buffer.byteLength(this.banner);
    var packetLen = 1 + 4 + bannerLen + 4;
    if (packetLen &gt; BUFFER_MAX_LEN) {
      bannerLen -= 1 + 4 + 4;
      packetLen -= 1 + 4 + 4;
    }
    var packet = new Buffer(packetLen);
    packet[0] = MESSAGE.USERAUTH_BANNER;
    packet.writeUInt32BE(bannerLen, 1, true);
    packet.write(this.banner, 5, bannerLen, 'utf8');
    packet.fill(0, packetLen - 4); // Empty language tag
    this.debug('DEBUG: Outgoing: Writing USERAUTH_BANNER');
    send(this, packet);
    this.banner = undefined; // Prevent banner from being displayed again
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.session" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.session">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>session
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">session = function (chan, initWindow, maxPacket) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var buf = new Buffer(1 + 4 + 7 + 4 + 4 + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(7, 1, true);
  buf.write('session', 5, 7, 'ascii');

  buf.writeUInt32BE(chan, 12, true);

  buf.writeUInt32BE(initWindow, 16, true);

  buf.writeUInt32BE(maxPacket, 20, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', session)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.shell" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.shell">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>shell
        <span class="apidocSignatureSpan">(chan, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shell = function (chan, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var buf = new Buffer(1 + 4 + 4 + 5 + 1);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(5, 5, true);
  buf.write('shell', 9, 5, 'ascii');

  buf[14] = (wantReply === undefined || wantReply === true ? 1 : 0);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', shell)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.signal" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.signal">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>signal
        <span class="apidocSignatureSpan">(chan, signal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signal = function (chan, signal) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  signal = signal.toUpperCase();
  if (signal.slice(0, 3) === 'SIG')
    signal = signal.substring(3);

  if (SIGNALS.indexOf(signal) === -1)
    throw new Error('Invalid signal: ' + signal);

  var signalLen = signal.length;
  var buf = new Buffer(1 + 4 + 4 + 6 + 1 + 4 + signalLen);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(6, 5, true);
  buf.write('signal', 9, 6, 'ascii');

  buf[15] = 0;

  buf.writeUInt32BE(signalLen, 16, true);
  buf.write(signal, 20, signalLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', signal)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.subsystem" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.subsystem">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>subsystem
        <span class="apidocSignatureSpan">(chan, name, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subsystem = function (chan, name, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var nameLen = Buffer.byteLength(name);
  var buf = new Buffer(1 + 4 + 4 + 9 + 1 + 4 + nameLen);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(9, 5, true);
  buf.write('subsystem', 9, 9, 'ascii');

  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(nameLen, 19, true);
  buf.write(name, 23, nameLen, 'ascii');

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', subsystem: '
             + name
             + ')');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.tcpipForward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.tcpipForward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>tcpipForward
        <span class="apidocSignatureSpan">(bindAddr, bindPort, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tcpipForward = function (bindAddr, bindPort, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  var addrlen = Buffer.byteLength(bindAddr);
  var buf = new Buffer(1 + 4 + 13 + 1 + 4 + addrlen + 4);

  buf[0] = MESSAGE.GLOBAL_REQUEST;

  buf.writeUInt32BE(13, 1, true);
  buf.write('tcpip-forward', 5, 13, 'ascii');

  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf.writeUInt32BE(addrlen, 19, true);
  buf.write(bindAddr, 23, addrlen, 'ascii');

  buf.writeUInt32BE(bindPort, 23 + addrlen, true);

  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (tcpip-forward)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.windowChange" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.windowChange">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>windowChange
        <span class="apidocSignatureSpan">(chan, rows, cols, height, width)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">windowChange = function (chan, rows, cols, height, width) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var buf = new Buffer(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(13, 5, true);
  buf.write('window-change', 9, 13, 'ascii');

  buf[22] = 0;

  buf.writeUInt32BE(cols, 23, true);

  buf.writeUInt32BE(rows, 27, true);

  buf.writeUInt32BE(width, 31, true);

  buf.writeUInt32BE(height, 35, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', window-change)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.x11" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.x11">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>x11
        <span class="apidocSignatureSpan">(chan, initWindow, maxPacket, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">x11 = function (chan, initWindow, maxPacket, cfg) {
  if (!this.server)
    throw new Error('Server-only method called in client mode');

  var addrLen = Buffer.byteLength(cfg.originAddr);
  var p = 24 + addrLen;
  var buf = new Buffer(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);

  buf[0] = MESSAGE.CHANNEL_OPEN;

  buf.writeUInt32BE(3, 1, true);
  buf.write('x11', 5, 3, 'ascii');

  buf.writeUInt32BE(chan, 8, true);

  buf.writeUInt32BE(initWindow, 12, true);

  buf.writeUInt32BE(maxPacket, 16, true);

  buf.writeUInt32BE(addrLen, 20, true);
  buf.write(cfg.originAddr, 24, addrLen, 'ascii');

  buf.writeUInt32BE(cfg.originPort, p, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('
             + chan
             + ', x11)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.SSH2Stream.prototype.x11Forward" id="apidoc.element.ssh2-streams.SSH2Stream.prototype.x11Forward">
        function <span class="apidocSignatureSpan">ssh2-streams.SSH2Stream.prototype.</span>x11Forward
        <span class="apidocSignatureSpan">(chan, cfg, wantReply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">x11Forward = function (chan, cfg, wantReply) {
  if (this.server)
    throw new Error('Client-only method called in server mode');

  // Does not consume window space
  var protolen = Buffer.byteLength(cfg.protocol);
  var cookielen = Buffer.byteLength(cfg.cookie);
  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 1 + 4 + protolen + 4 + cookielen
                       + 4);

  buf[0] = MESSAGE.CHANNEL_REQUEST;

  buf.writeUInt32BE(chan, 1, true);

  buf.writeUInt32BE(7, 5, true);
  buf.write('x11-req', 9, 7, 'ascii');

  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);

  buf[17] = (cfg.single ? 1 : 0);

  buf.writeUInt32BE(protolen, 18, true);
  var bp = 22;
  if (Buffer.isBuffer(cfg.protocol))
    cfg.protocol.copy(buf, bp);
  else
    buf.write(cfg.protocol, bp, protolen, 'utf8');
  bp += protolen;

  buf.writeUInt32BE(cookielen, bp, true);
  bp += 4;
  if (Buffer.isBuffer(cfg.cookie))
    cfg.cookie.copy(buf, bp);
  else
    buf.write(cfg.cookie, bp, cookielen, 'utf8');
  bp += cookielen;

  buf.writeUInt32BE((cfg.screen || 0), bp, true);

  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('
             + chan
             + ', x11-req)');
  return send(this, buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.jsbn" id="apidoc.module.ssh2-streams.jsbn">module ssh2-streams.jsbn</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.jsbn" id="apidoc.element.ssh2-streams.jsbn.jsbn">
        function <span class="apidocSignatureSpan">ssh2-streams.</span>jsbn
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.jsbn.prototype" id="apidoc.module.ssh2-streams.jsbn.prototype">module ssh2-streams.jsbn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.Barrett" id="apidoc.element.ssh2-streams.jsbn.prototype.Barrett">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>Barrett
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.abs" id="apidoc.element.ssh2-streams.jsbn.prototype.abs">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAbs() { return (this.s&lt;0)?this.negate():this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.t = i;
r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
var x = this.<span class="apidocCodeKeywordSpan">abs</span>(), y = a.abs();
var i = x.t;
r.t = i+y.t;
while(--i &gt;= 0) r[i] = 0;
for(i = 0; i &lt; y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
r.s = 0;
r.clamp();
if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.add" id="apidoc.element.ssh2-streams.jsbn.prototype.add">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>add
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) &gt;= 0) return d.subtract(m);
  if(d.signum() &lt; 0) d.addTo(m,d); else return d;
  if(d.signum() &lt; 0) return d.<span class="apidocCodeKeywordSpan">add</span>(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,
151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,
337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,
541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,
743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,
971,977,983,991,997];
var lplim = (1&lt;&lt;26)/lowprimes[lowprimes.length-1];

// (public) test primality with certainty &gt;= 1-.5^t
function bnIsProbablePrime(t) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.addTo" id="apidoc.element.ssh2-streams.jsbn.prototype.addTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>addTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpAddTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i &lt; m) {
    c += this[i]+a[i];
    r[i++] = c&amp;this.DM;
    c &gt;&gt;= this.DB;
  }
  if(a.t &lt; this.t) {
    c += a.s;
    while(i &lt; this.t) {
      c += this[i];
      r[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i &lt; a.t) {
      c += a[i];
      r[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c += a.s;
  }
  r.s = (c&lt;0)?-1:0;
  if(c &gt; 0) r[i++] = c;
  else if(c &lt; -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(c &gt; 0) r[i++] = c;
  else if(c &lt; -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}

// (public) this + a
function bnAdd(a) { var r = nbi(); this.<span class="apidocCodeKeywordSpan">addTo</span>(a,r); return r; }

// (public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

// (public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.am" id="apidoc.element.ssh2-streams.jsbn.prototype.am">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>am
        <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function am3(i, x, w, j, c, n) {
  var xl = x&amp;0x3fff, xh = x&gt;&gt;14;
  while(--n &gt;= 0) {
    var l = this[i]&amp;0x3fff;
    var h = this[i++]&gt;&gt;14;
    var m = xh*l+h*xl;
    l = xl*l+((m&amp;0x3fff)&lt;&lt;14)+w[j]+c;
    c = (l&gt;&gt;28)+(m&gt;&gt;14)+xh*h;
    w[j++] = l&amp;0xfffffff;
  }
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i &gt;= 0) r[i] = 0;
  for(i = 0; i &lt; y.t; ++i) r[i+x.t] = x.<span class="apidocCodeKeywordSpan">am</span>(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.and" id="apidoc.element.ssh2-streams.jsbn.prototype.and">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>and
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.andNot" id="apidoc.element.ssh2-streams.jsbn.prototype.andNot">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>andNot
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.bitCount" id="apidoc.element.ssh2-streams.jsbn.prototype.bitCount">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitCount() {
  var r = 0, x = this.s&amp;this.DM;
  for(var i = 0; i &lt; this.t; ++i) r += cbit(this[i]^x);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.bitLength" id="apidoc.element.ssh2-streams.jsbn.prototype.bitLength">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitLength() {
  if(this.t &lt;= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&amp;this.DM));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else {
    this.fromNumber(a,c);
    if(!this.testBit(a-1))  // force MSB set
      this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
    if(this.isEven()) this.dAddOffset(1,0); // force odd
    while(!this.isProbablePrime(b)) {
      this.dAddOffset(2,0);
      if(this.<span class="apidocCodeKeywordSpan">bitLength</span>() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
    }
  }
}
else {
  // new BigInteger(int,RNG)
  var x = new Array(), t = a&amp;7;
  x.length = (a&gt;&gt;3)+1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.bitwiseTo" id="apidoc.element.ssh2-streams.jsbn.prototype.bitwiseTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>bitwiseTo
        <span class="apidocSignatureSpan">(a, op, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpBitwiseTo(a, op, r) {
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i &lt; m; ++i) r[i] = op(this[i],a[i]);
  if(a.t &lt; this.t) {
    f = a.s&amp;this.DM;
    for(i = m; i &lt; this.t; ++i) r[i] = op(this[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&amp;this.DM;
    for(i = m; i &lt; a.t; ++i) r[i] = op(f,a[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
  // new BigInteger(int,int,RNG)
  if(a &lt; 2) this.fromInt(1);
  else {
    this.fromNumber(a,c);
    if(!this.testBit(a-1))  // force MSB set
      this.<span class="apidocCodeKeywordSpan">bitwiseTo</span>(BigInteger.ONE.shiftLeft(a-1),op_or,this);
    if(this.isEven()) this.dAddOffset(1,0); // force odd
    while(!this.isProbablePrime(b)) {
      this.dAddOffset(2,0);
      if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.byteValue" id="apidoc.element.ssh2-streams.jsbn.prototype.byteValue">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>byteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnByteValue() { return (this.t==0)?this.s:(this[0]&lt;&lt;24)&gt;&gt;24; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.changeBit" id="apidoc.element.ssh2-streams.jsbn.prototype.changeBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>changeBit
        <span class="apidocSignatureSpan">(n, op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

// (public) this | (1&lt;&lt;n)
function bnSetBit(n) { return this.<span class="apidocCodeKeywordSpan">changeBit</span>(n,op_or); }

// (public) this &amp; ~(1&lt;&lt;n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

// (public) this ^ (1&lt;&lt;n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.chunkSize" id="apidoc.element.ssh2-streams.jsbn.prototype.chunkSize">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>chunkSize
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.<span class="apidocCodeKeywordSpan">chunkSize</span>(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
  r = (a+z.intValue()).toString(b).substr(1) + r;
  y.divRemTo(d,y,z);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.clamp" id="apidoc.element.ssh2-streams.jsbn.prototype.clamp">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpClamp() {
  var c = this.s&amp;this.DM;
  while(this.t &gt; 0 &amp;&amp; this[this.t-1] == c) --this.t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sh += k;
  if(sh &gt;= this.DB) sh -= this.DB;
}
if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
  this.s = -1;
  if(sh &gt; 0) this[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
}
this.<span class="apidocCodeKeywordSpan">clamp</span>();
if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
var c = this.s&amp;this.DM;
while(this.t &gt; 0 &amp;&amp; this[this.t-1] == c) --this.t;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.clearBit" id="apidoc.element.ssh2-streams.jsbn.prototype.clearBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clearBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClearBit(n) { return this.changeBit(n,op_andnot); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.clone" id="apidoc.element.ssh2-streams.jsbn.prototype.clone">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClone() { var r = nbi(); this.copyTo(r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s&lt;0)?this.negate():this.<span class="apidocCodeKeywordSpan">clone</span>();
var y = (a.s&lt;0)?a.negate():a.clone();
if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
var i = x.getLowestSetBit(), g = y.getLowestSetBit();
if(g &lt; 0) return x;
if(i &lt; g) g = i;
if(g &gt; 0) {
  x.rShiftTo(g,x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.compareTo" id="apidoc.element.ssh2-streams.jsbn.prototype.compareTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>compareTo
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s&lt;0)?-r:r;
  while(--i &gt;= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ys = y.t;
var y0 = y[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
y.dlShiftTo(j,t);
if(r.<span class="apidocCodeKeywordSpan">compareTo</span>(t) &gt;= 0) {
  r[r.t++] = 1;
  r.subTo(t,r);
}
BigInteger.ONE.dlShiftTo(ys,t);
t.subTo(y,y);  // "negative" y so we can replace sub with am later
while(y.t &lt; ys) y[y.t++] = 0;
while(--j &gt;= 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.copyTo" id="apidoc.element.ssh2-streams.jsbn.prototype.copyTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>copyTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpCopyTo(r) {
  for(var i = this.t-1; i &gt;= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
var pm = m.abs();
if(pm.t &lt;= 0) return;
var pt = this.abs();
if(pt.t &lt; pm.t) {
  if(q != null) q.fromInt(0);
  if(r != null) this.<span class="apidocCodeKeywordSpan">copyTo</span>(r);
  return;
}
if(r == null) r = nbi();
var y = nbi(), ts = this.s, ms = m.s;
var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
if(nsh &gt; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
else { pm.copyTo(y); pt.copyTo(r); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.dAddOffset" id="apidoc.element.ssh2-streams.jsbn.prototype.dAddOffset">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dAddOffset
        <span class="apidocSignatureSpan">(n, w)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDAddOffset(n, w) {
  if(n == 0) return;
  while(this.t &lt;= w) this[this.t++] = 0;
  this[w] += n;
  while(this[w] &gt;= this.DV) {
    this[w] -= this.DV;
    if(++w &gt;= this.t) this[this.t++] = 0;
    ++this[w];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(x &lt; 0) {
    if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
    continue;
  }
  w = b*w+x;
  if(++j &gt;= cs) {
    this.dMultiply(d);
    this.<span class="apidocCodeKeywordSpan">dAddOffset</span>(w,0);
    j = 0;
    w = 0;
  }
}
if(j &gt; 0) {
  this.dMultiply(Math.pow(b,j));
  this.dAddOffset(w,0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.dMultiply" id="apidoc.element.ssh2-streams.jsbn.prototype.dMultiply">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dMultiply
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDMultiply(n) {
  this[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var x = intAt(s,i);
  if(x &lt; 0) {
    if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
    continue;
  }
  w = b*w+x;
  if(++j &gt;= cs) {
    this.<span class="apidocCodeKeywordSpan">dMultiply</span>(d);
    this.dAddOffset(w,0);
    j = 0;
    w = 0;
  }
}
if(j &gt; 0) {
  this.dMultiply(Math.pow(b,j));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.divRemTo" id="apidoc.element.ssh2-streams.jsbn.prototype.divRemTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divRemTo
        <span class="apidocSignatureSpan">(m, q, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if(pm.t &lt;= 0) return;
  var pt = this.abs();
  if(pt.t &lt; pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
  if(nsh &gt; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y[ys-2]&gt;&gt;this.F2:0);
  var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) &gt;= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);  // "negative" y so we can replace sub with am later
  while(y.t &lt; ys) y[y.t++] = 0;
  while(--j &gt;= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) &lt; qd) {   // Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] &lt; --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh &gt; 0) r.rShiftTo(nsh,r); // Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(nsh &gt; 0) r.rShiftTo(nsh,r); // Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().<span class="apidocCodeKeywordSpan">divRemTo</span>(a,null,r);
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.divide" id="apidoc.element.ssh2-streams.jsbn.prototype.divide">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divide
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Barrett modular reduction
function Barrett(m) {
// setup Barrett
this.r2 = nbi();
this.q3 = nbi();
BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
this.mu = this.r2.<span class="apidocCodeKeywordSpan">divide</span>(m);
this.m = m;
}

function barrettConvert(x) {
if(x.s &lt; 0 || x.t &gt; 2*this.m.t) return x.mod(this.m);
else if(x.compareTo(this.m) &lt; 0) return x;
else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.divideAndRemainder" id="apidoc.element.ssh2-streams.jsbn.prototype.divideAndRemainder">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>divideAndRemainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.dlShiftTo" id="apidoc.element.ssh2-streams.jsbn.prototype.dlShiftTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>dlShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDLShiftTo(n, r) {
  var i;
  for(i = this.t-1; i &gt;= 0; --i) r[i+n] = this[i];
  for(i = n-1; i &gt;= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else { pm.copyTo(y); pt.copyTo(r); }
var ys = y.t;
var y0 = y[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
y.<span class="apidocCodeKeywordSpan">dlShiftTo</span>(j,t);
if(r.compareTo(t) &gt;= 0) {
  r[r.t++] = 1;
  r.subTo(t,r);
}
BigInteger.ONE.dlShiftTo(ys,t);
t.subTo(y,y);  // "negative" y so we can replace sub with am later
while(y.t &lt; ys) y[y.t++] = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.drShiftTo" id="apidoc.element.ssh2-streams.jsbn.prototype.drShiftTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>drShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDRShiftTo(n, r) {
  for(var i = n; i &lt; this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if((r[i]+=y.am(0,qd,r,j,0,ys)) &lt; qd) {   // Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] &lt; --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.<span class="apidocCodeKeywordSpan">drShiftTo</span>(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh &gt; 0) r.rShiftTo(nsh,r); // Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.equals" id="apidoc.element.ssh2-streams.jsbn.prototype.equals">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>equals
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnEquals(a) { return(this.compareTo(a)==0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.exp" id="apidoc.element.ssh2-streams.jsbn.prototype.exp">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>exp
        <span class="apidocSignatureSpan">(e, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpExp(e, z) {
  if(e &gt; 0xffffffff || e &lt; 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i &gt;= 0) {
    z.sqrTo(r,r2);
    if((e&amp;(1&lt;&lt;i)) &gt; 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return z.revert(r);
}

// (public) this^e % m, 0 &lt;= e &lt; 2^32
function bnModPowInt(e,m) {
  var z;
  if(e &lt; 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.<span class="apidocCodeKeywordSpan">exp</span>(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.flipBit" id="apidoc.element.ssh2-streams.jsbn.prototype.flipBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>flipBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnFlipBit(n) { return this.changeBit(n,op_xor); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.fromInt" id="apidoc.element.ssh2-streams.jsbn.prototype.fromInt">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromInt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromInt(x) {
  this.t = 1;
  this.s = (x&lt;0)?-1:0;
  if(x &gt; 0) this[0] = x;
  else if(x &lt; -1) this[0] = x+this.DV;
  else this.t = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.s = (x&lt;0)?-1:0;
if(x &gt; 0) this[0] = x;
else if(x &lt; -1) this[0] = x+this.DV;
else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.<span class="apidocCodeKeywordSpan">fromInt</span>(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 256) k = 8; // byte array
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.fromNumber" id="apidoc.element.ssh2-streams.jsbn.prototype.fromNumber">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromNumber
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromNumber(a, b, c) {
  if("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if(a &lt; 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))  // force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0); // force odd
      while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
    // new BigInteger(int,RNG)
    var x = new Array(), t = a&amp;7;
    x.length = (a&gt;&gt;3)+1;
    b.nextBytes(x);
    if(t &gt; 0) x[0] &amp;= ((1&lt;&lt;t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&amp;0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.<span class="apidocCodeKeywordSpan">fromNumber</span>(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.fromRadix" id="apidoc.element.ssh2-streams.jsbn.prototype.fromRadix">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromRadix
        <span class="apidocSignatureSpan">(s, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromRadix(s, b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i &lt; s.length; ++i) {
    var x = intAt(s,i);
    if(x &lt; 0) {
      if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j &gt;= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j &gt; 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 256) k = 8; // byte array
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else { this.<span class="apidocCodeKeywordSpan">fromRadix</span>(s,b); return; }
this.t = 0;
this.s = 0;
var i = s.length, mi = false, sh = 0;
while(--i &gt;= 0) {
  var x = (k==8)?s[i]&amp;0xff:intAt(s,i);
  if(x &lt; 0) {
    if(s.charAt(i) == "-") mi = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.fromString" id="apidoc.element.ssh2-streams.jsbn.prototype.fromString">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>fromString
        <span class="apidocSignatureSpan">(s, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromString(s, b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i &gt;= 0) {
    var x = (k==8)?s[i]&amp;0xff:intAt(s,i);
    if(x &lt; 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k &gt; this.DB) {
      this[this.t-1] |= (x&amp;((1&lt;&lt;(this.DB-sh))-1))&lt;&lt;sh;
      this[this.t++] = (x&gt;&gt;(this.DB-sh));
    }
    else
      this[this.t-1] |= x&lt;&lt;sh;
    sh += k;
    if(sh &gt;= this.DB) sh -= this.DB;
  }
  if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
    this.s = -1;
    if(sh &gt; 0) this[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&amp;0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.<span class="apidocCodeKeywordSpan">fromString</span>(a,
256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.gcd" id="apidoc.element.ssh2-streams.jsbn.prototype.gcd">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>gcd
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGCD(a) {
  var x = (this.s&lt;0)?this.negate():this.clone();
  var y = (a.s&lt;0)?a.negate():a.clone();
  if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g &lt; 0) return x;
  if(i &lt; g) g = i;
  if(g &gt; 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() &gt; 0) {
    if((i = x.getLowestSetBit()) &gt; 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) &gt; 0) y.rShiftTo(i,y);
    if(x.compareTo(y) &gt;= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g &gt; 0) y.lShiftTo(g,y);
  return y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.getLowestSetBit" id="apidoc.element.ssh2-streams.jsbn.prototype.getLowestSetBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>getLowestSetBit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGetLowestSetBit() {
  for(var i = 0; i &lt; this.t; ++i)
    if(this[i] != 0) return i*this.DB+lbit(this[i]);
  if(this.s &lt; 0) return this.t*this.DB;
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s&lt;0)?this.negate():this.clone();
var y = (a.s&lt;0)?a.negate():a.clone();
if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
var i = x.<span class="apidocCodeKeywordSpan">getLowestSetBit</span>(), g = y.getLowestSetBit();
if(g &lt; 0) return x;
if(i &lt; g) g = i;
if(g &gt; 0) {
  x.rShiftTo(g,x);
  y.rShiftTo(g,y);
}
while(x.signum() &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.intValue" id="apidoc.element.ssh2-streams.jsbn.prototype.intValue">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>intValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIntValue() {
  if(this.s &lt; 0) {
    if(this.t == 1) return this[0]-this.DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this[0];
  else if(this.t == 0) return 0;
  // assumes 16 &lt; DB &lt; 32
  return ((this[1]&amp;((1&lt;&lt;(32-this.DB))-1))&lt;&lt;this.DB)|this[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(b == null) b = 10;
  if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() &gt; 0) {
    r = (a+z.<span class="apidocCodeKeywordSpan">intValue</span>()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s,b) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.invDigit" id="apidoc.element.ssh2-streams.jsbn.prototype.invDigit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>invDigit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpInvDigit() {
  if(this.t &lt; 1) return 0;
  var x = this[0];
  if((x&amp;1) == 0) return 0;
  var y = x&amp;3;       // y == 1/x mod 2^2
  y = (y*(2-(x&amp;0xf)*y))&amp;0xf; // y == 1/x mod 2^4
  y = (y*(2-(x&amp;0xff)*y))&amp;0xff;   // y == 1/x mod 2^8
  y = (y*(2-(((x&amp;0xffff)*y)&amp;0xffff)))&amp;0xffff;    // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 &lt; DB &lt;= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV &lt; y &lt; DV
  return (y&gt;0)?this.DV-y:-y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // we really want the negative inverse, and -DV &lt; y &lt; DV
  return (y&gt;0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.<span class="apidocCodeKeywordSpan">invDigit</span>();
  this.mpl = this.mp&amp;0x7fff;
  this.mph = this.mp&gt;&gt;15;
  this.um = (1&lt;&lt;(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.isEven" id="apidoc.element.ssh2-streams.jsbn.prototype.isEven">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpIsEven() { return ((this.t&gt;0)?(this[0]&amp;1):this.s) == 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return z.revert(r);
}

// (public) this^e % m, 0 &lt;= e &lt; 2^32
function bnModPowInt(e,m) {
  var z;
  if(e &lt; 256 || m.<span class="apidocCodeKeywordSpan">isEven</span>()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.isProbablePrime" id="apidoc.element.ssh2-streams.jsbn.prototype.isProbablePrime">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>isProbablePrime
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if(x.t == 1 &amp;&amp; x[0] &lt;= lowprimes[lowprimes.length-1]) {
    for(i = 0; i &lt; lowprimes.length; ++i)
      if(x[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i &lt; lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // new BigInteger(int,int,RNG)
  if(a &lt; 2) this.fromInt(1);
  else {
    this.fromNumber(a,c);
    if(!this.testBit(a-1))  // force MSB set
      this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
    if(this.isEven()) this.dAddOffset(1,0); // force odd
    while(!this.<span class="apidocCodeKeywordSpan">isProbablePrime</span>(b)) {
      this.dAddOffset(2,0);
      if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
    }
  }
}
else {
  // new BigInteger(int,RNG)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.lShiftTo" id="apidoc.element.ssh2-streams.jsbn.prototype.lShiftTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>lShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpLShiftTo(n, r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1&lt;&lt;cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s&lt;&lt;bs)&amp;this.DM, i;
  for(i = this.t-1; i &gt;= 0; --i) {
    r[i+ds+1] = (this[i]&gt;&gt;cbs)|c;
    c = (this[i]&amp;bm)&lt;&lt;bs;
  }
  for(i = ds-1; i &gt;= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(q != null) q.fromInt(0);
  if(r != null) this.copyTo(r);
  return;
}
if(r == null) r = nbi();
var y = nbi(), ts = this.s, ms = m.s;
var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
if(nsh &gt; 0) { pm.<span class="apidocCodeKeywordSpan">lShiftTo</span>(nsh,y); pt.lShiftTo(nsh,r); }
else { pm.copyTo(y); pt.copyTo(r); }
var ys = y.t;
var y0 = y[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.max" id="apidoc.element.ssh2-streams.jsbn.prototype.max">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>max
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMax(a) { return(this.compareTo(a)&gt;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.t = this.t+n;
r.s = this.s;
}

// (protected) r = this &gt;&gt; n*DB
function bnpDRShiftTo(n,r) {
for(var i = n; i &lt; this.t; ++i) r[i-n] = this[i];
r.t = Math.<span class="apidocCodeKeywordSpan">max</span>(this.t-n,0);
r.s = this.s;
}

// (protected) r = this &lt;&lt; n
function bnpLShiftTo(n,r) {
var bs = n%this.DB;
var cbs = this.DB-bs;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.millerRabin" id="apidoc.element.ssh2-streams.jsbn.prototype.millerRabin">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>millerRabin
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k &lt;= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)&gt;&gt;1;
  if(t &gt; lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i &lt; t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
i = 1;
while(i &lt; lowprimes.length) {
  var m = lowprimes[i], j = i+1;
  while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
  m = x.modInt(m);
  while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
}
return x.<span class="apidocCodeKeywordSpan">millerRabin</span>(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k &lt;= 0) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.min" id="apidoc.element.ssh2-streams.jsbn.prototype.min">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>min
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMin(a) { return(this.compareTo(a)&lt;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(bs &gt; 0) r[this.t-ds-1] |= (this.s&amp;bm)&lt;&lt;cbs;
r.t = this.t-ds;
r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
var i = 0, c = 0, m = Math.<span class="apidocCodeKeywordSpan">min</span>(a.t,this.t);
while(i &lt; m) {
  c += this[i]-a[i];
  r[i++] = c&amp;this.DM;
  c &gt;&gt;= this.DB;
}
if(a.t &lt; this.t) {
  c -= a.s;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.mod" id="apidoc.element.ssh2-streams.jsbn.prototype.mod">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>mod
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.<span class="apidocCodeKeywordSpan">mod</span>(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.modInt" id="apidoc.element.ssh2-streams.jsbn.prototype.modInt">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpModInt(n) {
  if(n &lt;= 0) return 0;
  var d = this.DV%n, r = (this.s&lt;0)?n-1:0;
  if(this.t &gt; 0)
    if(d == 0) r = this[0]%n;
    else for(var i = this.t-1; i &gt;= 0; --i) r = (d*r+this[i])%n;
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i &lt; lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
    m = x.<span class="apidocCodeKeywordSpan">modInt</span>(m);
    while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.modInverse" id="apidoc.element.ssh2-streams.jsbn.prototype.modInverse">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modInverse
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() &amp;&amp; ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum() != 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) &gt;= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) &gt;= 0) return d.subtract(m);
  if(d.signum() &lt; 0) d.addTo(m,d); else return d;
  if(d.signum() &lt; 0) return d.add(m); else return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.modPow" id="apidoc.element.ssh2-streams.jsbn.prototype.modPow">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modPow
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPow(e, m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if(i &lt;= 0) return r;
  else if(i &lt; 18) k = 1;
  else if(i &lt; 48) k = 3;
  else if(i &lt; 144) k = 4;
  else if(i &lt; 768) k = 5;
  else k = 6;
  if(i &lt; 8)
    z = new Classic(m);
  else if(m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);

  // precomputation
  var g = new Array(), n = 3, k1 = k-1, km = (1&lt;&lt;k)-1;
  g[1] = z.convert(this);
  if(k &gt; 1) {
    var g2 = nbi();
    z.sqrTo(g[1],g2);
    while(n &lt;= km) {
      g[n] = nbi();
      z.mulTo(g2,g[n-2],g[n]);
      n += 2;
    }
  }

  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j])-1;
  while(j &gt;= 0) {
    if(i &gt;= k1) w = (e[j]&gt;&gt;(i-k1))&amp;km;
    else {
      w = (e[j]&amp;((1&lt;&lt;(i+1))-1))&lt;&lt;(k1-i);
      if(j &gt; 0) w |= e[j-1]&gt;&gt;(this.DB+i-k1);
    }

    n = k;
    while((w&amp;1) == 0) { w &gt;&gt;= 1; --n; }
    if((i -= n) &lt; 0) { i += this.DB; --j; }
    if(is1) {  // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r);
      is1 = false;
    }
    else {
      while(n &gt; 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
      if(n &gt; 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
      z.mulTo(r2,g[w],r);
    }

    while(j &gt;= 0 &amp;&amp; (e[j]&amp;(1&lt;&lt;i)) == 0) {
      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
      if(--i &lt; 0) { i = this.DB-1; --j; }
    }
  }
  return z.revert(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var r = n1.shiftRight(k);
t = (t+1)&gt;&gt;1;
if(t &gt; lowprimes.length) t = lowprimes.length;
var a = nbi();
for(var i = 0; i &lt; t; ++i) {
  //Pick bases at random, instead of starting at 2
  a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
  var y = a.<span class="apidocCodeKeywordSpan">modPow</span>(r,this);
  if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
    var j = 1;
    while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
      y = y.modPowInt(2,this);
      if(y.compareTo(BigInteger.ONE) == 0) return false;
    }
    if(y.compareTo(n1) != 0) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.modPowInt" id="apidoc.element.ssh2-streams.jsbn.prototype.modPowInt">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>modPowInt
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPowInt(e, m) {
  var z;
  if(e &lt; 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for(var i = 0; i &lt; t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
        y = y.<span class="apidocCodeKeywordSpan">modPowInt</span>(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.multiply" id="apidoc.element.ssh2-streams.jsbn.prototype.multiply">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiply
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyLowerTo" id="apidoc.element.ssh2-streams.jsbn.prototype.multiplyLowerTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyLowerTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t+a.t,n);
  r.s = 0; // assumes a,this &gt;= 0
  r.t = i;
  while(i &gt; 0) r[--i] = 0;
  var j;
  for(j = r.t-this.t; i &lt; j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i &lt; j; ++i) this.am(0,a[i],r,i,0,n-i);
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t &gt; this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.<span class="apidocCodeKeywordSpan">multiplyLowerTo</span>(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) &lt; 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) &gt;= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyTo" id="apidoc.element.ssh2-streams.jsbn.prototype.multiplyTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i &gt;= 0) r[i] = 0;
  for(i = 0; i &lt; y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.<span class="apidocCodeKeywordSpan">multiplyTo</span>(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.multiplyUpperTo" id="apidoc.element.ssh2-streams.jsbn.prototype.multiplyUpperTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>multiplyUpperTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0; // assumes a,this &gt;= 0
  while(--i &gt;= 0) r[i] = 0;
  for(i = Math.max(n-this.t,0); i &lt; a.t; ++i)
    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t &gt; this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.<span class="apidocCodeKeywordSpan">multiplyUpperTo</span>(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) &lt; 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) &gt;= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.negate" id="apidoc.element.ssh2-streams.jsbn.prototype.negate">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpClamp() {
var c = this.s&amp;this.DM;
while(this.t &gt; 0 &amp;&amp; this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
if(this.s &lt; 0) return "-"+this.<span class="apidocCodeKeywordSpan">negate</span>().toString(b);
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else return this.toRadix(b);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.not" id="apidoc.element.ssh2-streams.jsbn.prototype.not">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNot() {
  var r = nbi();
  for(var i = 0; i &lt; this.t; ++i) r[i] = this.DM&amp;~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.or" id="apidoc.element.ssh2-streams.jsbn.prototype.or">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>or
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.pow" id="apidoc.element.ssh2-streams.jsbn.prototype.pow">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>pow
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnPow(e) { return this.exp(e,new NullExp()); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dbits = 28;

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1&lt;&lt;dbits)-1);
BigInteger.prototype.DV = (1&lt;&lt;dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.<span class="apidocCodeKeywordSpan">pow</span>(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.rShiftTo" id="apidoc.element.ssh2-streams.jsbn.prototype.rShiftTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>rShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds &gt;= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1&lt;&lt;bs)-1;
  r[0] = this[ds]&gt;&gt;bs;
  for(var i = ds+1; i &lt; this.t; ++i) {
    r[i-ds-1] |= (this[i]&amp;bm)&lt;&lt;cbs;
    r[i-ds] = this[i]&gt;&gt;bs;
  }
  if(bs &gt; 0) r[this.t-ds-1] |= (this.s&amp;bm)&lt;&lt;cbs;
  r.t = this.t-ds;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if(q != null) {
  r.drShiftTo(ys,q);
  if(ts != ms) BigInteger.ZERO.subTo(q,q);
}
r.t = ys;
r.clamp();
if(nsh &gt; 0) r.<span class="apidocCodeKeywordSpan">rShiftTo</span>(nsh,r); // Denormalize remainder
if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
var r = nbi();
this.abs().divRemTo(a,null,r);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.remainder" id="apidoc.element.ssh2-streams.jsbn.prototype.remainder">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>remainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.setBit" id="apidoc.element.ssh2-streams.jsbn.prototype.setBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>setBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSetBit(n) { return this.changeBit(n,op_or); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.shiftLeft" id="apidoc.element.ssh2-streams.jsbn.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftLeft(n) {
  var r = nbi();
  if(n &lt; 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
  // new BigInteger(int,int,RNG)
  if(a &lt; 2) this.fromInt(1);
  else {
    this.fromNumber(a,c);
    if(!this.testBit(a-1))  // force MSB set
      this.bitwiseTo(BigInteger.ONE.<span class="apidocCodeKeywordSpan">shiftLeft</span>(a-1),op_or,this);
    if(this.isEven()) this.dAddOffset(1,0); // force odd
    while(!this.isProbablePrime(b)) {
      this.dAddOffset(2,0);
      if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.shiftRight" id="apidoc.element.ssh2-streams.jsbn.prototype.shiftRight">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftRight(n) {
  var r = nbi();
  if(n &lt; 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k &lt;= 0) return false;
var r = n1.<span class="apidocCodeKeywordSpan">shiftRight</span>(k);
t = (t+1)&gt;&gt;1;
if(t &gt; lowprimes.length) t = lowprimes.length;
var a = nbi();
for(var i = 0; i &lt; t; ++i) {
  //Pick bases at random, instead of starting at 2
  a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
  var y = a.modPow(r,this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.shortValue" id="apidoc.element.ssh2-streams.jsbn.prototype.shortValue">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>shortValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShortValue() { return (this.t==0)?this.s:(this[0]&lt;&lt;16)&gt;&gt;16; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.signum" id="apidoc.element.ssh2-streams.jsbn.prototype.signum">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>signum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSigNum() {
  if(this.s &lt; 0) return -1;
  else if(this.t &lt;= 0 || (this.t == 1 &amp;&amp; this[0] &lt;= 0)) return 0;
  else return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if(this.t &lt;= 0 || (this.t == 1 &amp;&amp; this[0] &lt;= 0)) return 0;
else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.<span class="apidocCodeKeywordSpan">signum</span>() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
  r = (a+z.intValue()).toString(b).substr(1) + r;
  y.divRemTo(d,y,z);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.square" id="apidoc.element.ssh2-streams.jsbn.prototype.square">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>square
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSquare() { var r = nbi(); this.squareTo(r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.squareTo" id="apidoc.element.ssh2-streams.jsbn.prototype.squareTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>squareTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i &gt;= 0) r[i] = 0;
  for(i = 0; i &lt; x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) &gt;= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t &gt; 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.<span class="apidocCodeKeywordSpan">squareTo</span>(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.subTo" id="apidoc.element.ssh2-streams.jsbn.prototype.subTo">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>subTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSubTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i &lt; m) {
    c += this[i]-a[i];
    r[i++] = c&amp;this.DM;
    c &gt;&gt;= this.DB;
  }
  if(a.t &lt; this.t) {
    c -= a.s;
    while(i &lt; this.t) {
      c += this[i];
      r[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i &lt; a.t) {
      c -= a[i];
      r[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c -= a.s;
  }
  r.s = (c&lt;0)?-1:0;
  if(c &lt; -1) r[i++] = this.DV+c;
  else if(c &gt; 0) r[i++] = c;
  r.t = i;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(sh &gt;= this.DB) sh -= this.DB;
  }
  if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
    this.s = -1;
    if(sh &gt; 0) this[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.<span class="apidocCodeKeywordSpan">subTo</span>(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&amp;this.DM;
  while(this.t &gt; 0 &amp;&amp; this[this.t-1] == c) --this.t;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.subtract" id="apidoc.element.ssh2-streams.jsbn.prototype.subtract">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>subtract
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) &gt;= 0) return d.<span class="apidocCodeKeywordSpan">subtract</span>(m);
  if(d.signum() &lt; 0) d.addTo(m,d); else return d;
  if(d.signum() &lt; 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,
151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,
337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,
541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,
743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,
971,977,983,991,997];
var lplim = (1&lt;&lt;26)/lowprimes[lowprimes.length-1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.testBit" id="apidoc.element.ssh2-streams.jsbn.prototype.testBit">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>testBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnTestBit(n) {
  var j = Math.floor(n/this.DB);
  if(j &gt;= this.t) return(this.s!=0);
  return((this[j]&amp;(1&lt;&lt;(n%this.DB)))!=0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (protected) alternate constructor
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
  // new BigInteger(int,int,RNG)
  if(a &lt; 2) this.fromInt(1);
  else {
    this.fromNumber(a,c);
    if(!this.<span class="apidocCodeKeywordSpan">testBit</span>(a-1))  // force MSB set
      this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
    if(this.isEven()) this.dAddOffset(1,0); // force odd
    while(!this.isProbablePrime(b)) {
      this.dAddOffset(2,0);
      if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.toByteArray" id="apidoc.element.ssh2-streams.jsbn.prototype.toByteArray">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toByteArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB-(i*this.DB)%8, d, k = 0;
  if(i-- &gt; 0) {
    if(p &lt; this.DB &amp;&amp; (d = this[i]&gt;&gt;p) != (this.s&amp;this.DM)&gt;&gt;p)
      r[k++] = d|(this.s&lt;&lt;(this.DB-p));
    while(i &gt;= 0) {
      if(p &lt; 8) {
        d = (this[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(8-p);
        d |= this[--i]&gt;&gt;(p+=this.DB-8);
      }
      else {
        d = (this[i]&gt;&gt;(p-=8))&amp;0xff;
        if(p &lt;= 0) { p += this.DB; --i; }
      }
      if((d&amp;0x80) != 0) d |= -256;
      if(k == 0 &amp;&amp; (this.s&amp;0x80) != (d&amp;0x80)) ++k;
      if(k &gt; 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.toRadix" id="apidoc.element.ssh2-streams.jsbn.prototype.toRadix">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toRadix
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() &gt; 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(this.s &lt; 0) return "-"+this.negate().toString(b);
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else return this.<span class="apidocCodeKeywordSpan">toRadix</span>(b);
var km = (1&lt;&lt;k)-1, d, m = false, r = "", i = this.t;
var p = this.DB-(i*this.DB)%k;
if(i-- &gt; 0) {
  if(p &lt; this.DB &amp;&amp; (d = this[i]&gt;&gt;p) &gt; 0) { m = true; r = int2char(d); }
  while(i &gt;= 0) {
    if(p &lt; k) {
      d = (this[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(k-p);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.toString" id="apidoc.element.ssh2-streams.jsbn.prototype.toString">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>toString
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToString(b) {
  if(this.s &lt; 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1&lt;&lt;k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- &gt; 0) {
    if(p &lt; this.DB &amp;&amp; (d = this[i]&gt;&gt;p) &gt; 0) { m = true; r = int2char(d); }
    while(i &gt;= 0) {
      if(p &lt; k) {
        d = (this[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(k-p);
        d |= this[--i]&gt;&gt;(p+=this.DB-k);
      }
      else {
        d = (this[i]&gt;&gt;(p-=k))&amp;km;
        if(p &lt;= 0) { p += this.DB; --i; }
      }
      if(d &gt; 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpClamp() {
var c = this.s&amp;this.DM;
while(this.t &gt; 0 &amp;&amp; this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
if(this.s &lt; 0) return "-"+this.negate().<span class="apidocCodeKeywordSpan">toString</span>(b);
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else return this.toRadix(b);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.jsbn.prototype.xor" id="apidoc.element.ssh2-streams.jsbn.prototype.xor">
        function <span class="apidocSignatureSpan">ssh2-streams.jsbn.prototype.</span>xor
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ssh2-streams.utils" id="apidoc.module.ssh2-streams.utils">module ssh2-streams.utils</a></h1>


    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.DSAKeySSHToASN1" id="apidoc.element.ssh2-streams.utils.DSAKeySSHToASN1">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSAKeySSHToASN1
        <span class="apidocSignatureSpan">(key, self, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DSAKeySSHToASN1(key, self, callback) {
  // Convert SSH key parameters to ASN.1 BER values for OpenSSL
  var p = readString(key, key._pos, self, callback);
  if (p === false)
    return false;
  var q = readString(key, key._pos, self, callback);
  if (q === false)
    return false;
  var g = readString(key, key._pos, self, callback);
  if (g === false)
    return false;
  var y = readString(key, key._pos, self, callback);
  if (y === false)
    return false;

  var asnWriter = new Ber.Writer();
  asnWriter.startSequence();
    // algorithm
    asnWriter.startSequence();
      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa
      // algorithm parameters
      asnWriter.startSequence();
        asnWriter.writeBuffer(p, Ber.Integer);
        asnWriter.writeBuffer(q, Ber.Integer);
        asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.endSequence();
    asnWriter.endSequence();

    // subjectPublicKey
    asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0x00);
      asnWriter.writeBuffer(y, Ber.Integer);
    asnWriter.endSequence();
  asnWriter.endSequence();
  return asnWriter.buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.DSASigBERToBare" id="apidoc.element.ssh2-streams.utils.DSASigBERToBare">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSASigBERToBare
        <span class="apidocSignatureSpan">(signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DSASigBERToBare(signature) {
  if (signature.length &lt;= 40)
    return signature;
  // This is a quick and dirty way to get from BER encoded r and s that
  // OpenSSL gives us, to just the bare values back to back (40 bytes
  // total) like OpenSSH (and possibly others) are expecting
  var asnReader = new Ber.Reader(signature);
  asnReader.readSequence();
  var r = asnReader.readString(Ber.Integer, true);
  var s = asnReader.readString(Ber.Integer, true);
  var rOffset = 0;
  var sOffset = 0;
  if (r.length &lt; 20) {
    var rNew = new Buffer(20);
    r.copy(rNew, 1);
    r = rNew;
    r[0] = 0;
  }
  if (s.length &lt; 20) {
    var sNew = new Buffer(20);
    s.copy(sNew, 1);
    s = sNew;
    s[0] = 0;
  }
  if (r.length &gt; 20 &amp;&amp; r[0] === 0x00)
    rOffset = 1;
  if (s.length &gt; 20 &amp;&amp; s[0] === 0x00)
    sOffset = 1;
  var newSig = new Buffer((r.length - rOffset) + (s.length - sOffset));
  r.copy(newSig, 0, rOffset);
  s.copy(newSig, r.length - rOffset, sOffset);
  return newSig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.DSASigBareToBER" id="apidoc.element.ssh2-streams.utils.DSASigBareToBER">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>DSASigBareToBER
        <span class="apidocSignatureSpan">(signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DSASigBareToBER(signature) {
  if (signature.length &gt; 40)
    return signature;
  // Change bare signature r and s values to ASN.1 BER values for OpenSSL
  var asnWriter = new Ber.Writer();
  asnWriter.startSequence();
  var r = signature.slice(0, 20);
  var s = signature.slice(20);
  if (r[0] &amp; 0x80) {
    var rNew = new Buffer(21);
    rNew[0] = 0x00;
    r.copy(rNew, 1);
    r = rNew;
  } else if (r[0] === 0x00 &amp;&amp; !(r[1] &amp; 0x80)) {
    r = r.slice(1);
  }
  if (s[0] &amp; 0x80) {
    var sNew = new Buffer(21);
    sNew[0] = 0x00;
    s.copy(sNew, 1);
    s = sNew;
  } else if (s[0] === 0x00 &amp;&amp; !(s[1] &amp; 0x80)) {
    s = s.slice(1);
  }
  asnWriter.writeBuffer(r, Ber.Integer);
  asnWriter.writeBuffer(s, Ber.Integer);
  asnWriter.endSequence();
  return asnWriter.buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.ECDSAKeySSHToASN1" id="apidoc.element.ssh2-streams.utils.ECDSAKeySSHToASN1">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSAKeySSHToASN1
        <span class="apidocSignatureSpan">(key, self, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ECDSAKeySSHToASN1(key, self, callback) {
  // Convert SSH key parameters to ASN.1 BER values for OpenSSL
  var curve = readString(key, key._pos, self, callback);
  if (curve === false)
    return false;
  var Q = readString(key, key._pos, self, callback);
  if (Q === false)
    return false;

  var ecCurveOID;
  switch (curve.toString('ascii')) {
    case 'nistp256':
      // prime256v1/secp256r1
      ecCurveOID = '1.2.840.10045.3.1.7';
      break;
    case 'nistp384':
      // secp384r1
      ecCurveOID = '1.3.132.0.34';
      break;
    case 'nistp521':
      // secp521r1
      ecCurveOID = '1.3.132.0.35';
      break;
    default:
      return false;
  }
  var asnWriter = new Ber.Writer();
  asnWriter.startSequence();
    // algorithm
    asnWriter.startSequence();
      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey
      // algorithm parameters (namedCurve)
      asnWriter.writeOID(ecCurveOID);
    asnWriter.endSequence();

    // subjectPublicKey
    asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0x00);
      // XXX: hack to write a raw buffer without a tag -- yuck
      asnWriter._ensure(Q.length);
      Q.copy(asnWriter._buf, asnWriter._offset, 0, Q.length);
      asnWriter._offset += Q.length;
      // end hack
    asnWriter.endSequence();
  asnWriter.endSequence();
  return asnWriter.buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.ECDSASigASN1ToSSH" id="apidoc.element.ssh2-streams.utils.ECDSASigASN1ToSSH">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSASigASN1ToSSH
        <span class="apidocSignatureSpan">(signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ECDSASigASN1ToSSH(signature) {
  if (signature[0] === 0x00)
    return signature;
  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL
  var asnReader = new Ber.Reader(signature);
  asnReader.readSequence();
  var r = asnReader.readString(Ber.Integer, true);
  var s = asnReader.readString(Ber.Integer, true);
  if (r === null || s === null)
    throw new Error('Invalid signature');
  var newSig = new Buffer(4 + r.length + 4 + s.length);
  newSig.writeUInt32BE(r.length, 0, true);
  r.copy(newSig, 4);
  newSig.writeUInt32BE(s.length, 4 + r.length, true);
  s.copy(newSig, 4 + 4 + r.length);
  return newSig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.ECDSASigSSHToASN1" id="apidoc.element.ssh2-streams.utils.ECDSASigSSHToASN1">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>ECDSASigSSHToASN1
        <span class="apidocSignatureSpan">(signature, self, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ECDSASigSSHToASN1(signature, self, callback) {
  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL
  var r = readString(signature, 0, self, callback);
  if (r === false)
    return false;
  var s = readString(signature, signature._pos, self, callback);
  if (s === false)
    return false;

  var asnWriter = new Ber.Writer();
  asnWriter.startSequence();
  asnWriter.writeBuffer(r, Ber.Integer);
  asnWriter.writeBuffer(s, Ber.Integer);
  asnWriter.endSequence();
  return asnWriter.buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.RSAKeySSHToASN1" id="apidoc.element.ssh2-streams.utils.RSAKeySSHToASN1">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>RSAKeySSHToASN1
        <span class="apidocSignatureSpan">(key, self, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RSAKeySSHToASN1(key, self, callback) {
  // Convert SSH key parameters to ASN.1 BER values for OpenSSL
  var e = readString(key, key._pos, self, callback);
  if (e === false)
    return false;
  var n = readString(key, key._pos, self, callback);
  if (n === false)
    return false;

  var asnWriter = new Ber.Writer();
  asnWriter.startSequence();
    // algorithm
    asnWriter.startSequence();
      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption
      // algorithm parameters (RSA has none)
      asnWriter.writeNull();
    asnWriter.endSequence();

    // subjectPublicKey
    asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0x00);
      asnWriter.startSequence();
        asnWriter.writeBuffer(n, Ber.Integer);
        asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.endSequence();
    asnWriter.endSequence();
  asnWriter.endSequence();
  return asnWriter.buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.convertPPKPrivate" id="apidoc.element.ssh2-streams.utils.convertPPKPrivate">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>convertPPKPrivate
        <span class="apidocSignatureSpan">(keyInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertPPKPrivate(keyInfo) {
  if (!keyInfo.ppk || !keyInfo.public || !keyInfo.private)
    throw new Error("Key isn't a PPK");
  else if (keyInfo._converted)
    return false;

  var pub = keyInfo.public;
  var priv = keyInfo.private;
  var asnWriter = new Ber.Writer();
  var p;
  var q;

  if (keyInfo.type === 'rsa') {
    var e = readString(pub, 4 + 7);
    var n = readString(pub, pub._pos);
    var d = readString(priv, 0);
    p = readString(priv, priv._pos);
    q = readString(priv, priv._pos);
    var iqmp = readString(priv, priv._pos);
    var p1 = new BigInteger(p, 256);
    var q1 = new BigInteger(q, 256);
    var dmp1 = new BigInteger(d, 256);
    var dmq1 = new BigInteger(d, 256);

    dmp1 = new Buffer(dmp1.mod(p1.subtract(BigInteger.ONE)).toByteArray());
    dmq1 = new Buffer(dmq1.mod(q1.subtract(BigInteger.ONE)).toByteArray());

    asnWriter.startSequence();
      asnWriter.writeInt(0x00, Ber.Integer);
      asnWriter.writeBuffer(n, Ber.Integer);
      asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.writeBuffer(d, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(dmp1, Ber.Integer);
      asnWriter.writeBuffer(dmq1, Ber.Integer);
      asnWriter.writeBuffer(iqmp, Ber.Integer);
    asnWriter.endSequence();
  } else {
    p = readString(pub, 4 + 7);
    q = readString(pub, pub._pos);
    var g = readString(pub, pub._pos);
    var y = readString(pub, pub._pos);
    var x = readString(priv, 0);

    asnWriter.startSequence();
      asnWriter.writeInt(0x00, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.writeBuffer(x, Ber.Integer);
    asnWriter.endSequence();
  }

  var b64key = asnWriter.buffer.toString('base64').replace(RE_KEY_LEN, '$1\n');
  var fullkey = '-----BEGIN '
                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')
                + ' PRIVATE KEY-----\n'
                + b64key
                + (b64key[b64key.length - 1] === '\n' ? '' : '\n')
                + '-----END '
                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')
                + ' PRIVATE KEY-----';

  keyInfo.private = asnWriter.buffer;
  keyInfo.privateOrig = new Buffer(fullkey);
  keyInfo._converted = true;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ret.publicOrig = pubkey.publicOrig;

    ret.private = privateKey;

    // automatically convert private key data to OpenSSL format (including PEM)
    // if we don't need to wait for decryption
    if (!ret.encryption)
      utils.<span class="apidocCodeKeywordSpan">convertPPKPrivate</span>(ret);
  } else
    return new Error('Unsupported key format');

  return ret;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.decryptKey" id="apidoc.element.ssh2-streams.utils.decryptKey">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>decryptKey
        <span class="apidocSignatureSpan">(keyInfo, passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptKey(keyInfo, passphrase) {
  if (keyInfo._decrypted || !keyInfo.encryption)
    return;

  var keylen = 0;
  var key;
  var iv;
  var dc;

  keyInfo.encryption = (SSH_TO_OPENSSL[keyInfo.encryption]
                        || keyInfo.encryption);
  switch (keyInfo.encryption) {
    case 'aes-256-cbc':
    case 'aes-256-ctr':
      keylen = 32;
      break;
    case 'des-ede3-cbc':
    case 'des-ede3':
    case 'aes-192-cbc':
    case 'aes-192-ctr':
      keylen = 24;
      break;
    case 'aes-128-cbc':
    case 'aes-128-ctr':
    case 'cast-cbc':
    case 'bf-cbc':
      keylen = 16;
      break;
    default:
      throw new Error('Unsupported cipher for encrypted key: '
                      + keyInfo.encryption);
  }

  if (keyInfo.ppk) {
    iv = PPK_IV;

    key = Buffer.concat([
      crypto.createHash('sha1')
            .update('\x00\x00\x00\x00' + passphrase, 'utf8')
            .digest(),
      crypto.createHash('sha1')
            .update('\x00\x00\x00\x01' + passphrase, 'utf8')
            .digest()
    ]);
    key = key.slice(0, keylen);
  } else {
    iv = new Buffer(keyInfo.extra[0], 'hex');

    key = crypto.createHash('md5')
                .update(passphrase, 'utf8')
                .update(iv.slice(0, 8))
                .digest();

    while (keylen &gt; key.length) {
      key = Buffer.concat([
        key,
        (crypto.createHash('md5')
               .update(key)
               .update(passphrase, 'utf8')
               .update(iv)
               .digest()).slice(0, 8)
      ]);
    }
    if (key.length &gt; keylen)
      key = key.slice(0, keylen);
  }

  dc = crypto.createDecipheriv(keyInfo.encryption, key, iv);
  dc.setAutoPadding(false);
  keyInfo.private = Buffer.concat([ dc.update(keyInfo.private), dc.final() ]);

  keyInfo._decrypted = true;

  if (keyInfo.privateOrig) {
    // Update our original base64-encoded version of the private key
    var orig = keyInfo.privateOrig.toString('utf8');
    var newOrig = /^(.+(?:\r\n|\n))/.exec(orig)[1];
    var b64key = keyInfo.private.toString('base64');

    newOrig += b64key.match(/.{1,70}/g).join('\n');
    newOrig += /((?:\r\n|\n).+)$/.exec(orig)[1];

    keyInfo.privateOrig = newOrig;
  } else if (keyInfo.ppk) {
    var valid = verifyPPKMAC(keyInfo, passphrase, keyInfo.private);
    if (!valid)
      throw new Error('PPK MAC mismatch');
    // Automatically convert private key data to OpenSSL format
    // (including PEM)
    convertPPKPrivate(keyInfo);
  }

  // Fill in full key type
  // TODO: make DRY, we do this also in keyParser
  if (keyInfo.type !== 'ec') {
    keyInfo.fulltype = 'ssh-' + keyInfo.type;
  } else {
    // ECDSA
    var asnReader = new Ber.Reader(keyInfo.private);
    asnReader.readSequence();
    asnReader.readInt();
    asnReader.readString(Ber.OctetString, true);
    asnReader.readByte(); // Skip "complex" context type byte
    var offset = asnReader.readLength(); // Skip context length
    if (offset !== null) {
      asnReader._offset = offset;
      switch (asnReader.readOID()) {
        case '1.2.840.10045.3.1.7':
          // prime256v1/secp256r1
          keyInfo.fulltype = 'ecdsa-sha2-nistp256';
          break;
        case '1.3.132.0.34':
          // secp384r1
          keyInfo.fulltype = 'ecdsa-sha2-nistp384';
          break;
        case '1.3.132.0.35':
          // secp521r1
          keyInfo.fulltype = 'ecdsa-sha2-nistp521';
          break;
      }
    }
    if (keyInfo.fulltype === undefined)
      return new Error('Unsupported EC private key type');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.genPublicKey" id="apidoc.element.ssh2-streams.utils.genPublicKey">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>genPublicKey
        <span class="apidocSignatureSpan">(keyInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function genPublicKey(keyInfo) {
  var publicKey;
  var i;

  // RSA
  var n;
  var e;

  // DSA
  var p;
  var q;
  var g;
  var y;

  // ECDSA
  var d;
  var Q;
  var ecCurveOID;
  var ecCurveName;

  if (keyInfo.private) {
    // parsing private key in ASN.1 format in order to generate a public key
    var privKey = keyInfo.private;
    var asnReader = new Ber.Reader(privKey);
    var errMsg;

    if (asnReader.readSequence() === null) {
      errMsg = 'Malformed private key (expected sequence)';
      if (keyInfo._decrypted)
        errMsg += '. Bad passphrase?';
      throw new Error(errMsg);
    }

    // version (ignored)
    if (asnReader.readInt() === null) {
      errMsg = 'Malformed private key (expected version)';
      if (keyInfo._decrypted)
        errMsg += '. Bad passphrase?';
      throw new Error(errMsg);
    }

    if (keyInfo.type === 'rsa') {
      // modulus (n) -- integer
      n = asnReader.readString(Ber.Integer, true);
      if (n === null) {
        errMsg = 'Malformed private key (expected RSA n value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      // public exponent (e) -- integer
      e = asnReader.readString(Ber.Integer, true);
      if (e === null) {
        errMsg = 'Malformed private key (expected RSA e value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      publicKey = new Buffer(4 + 7 // ssh-rsa
                             + 4 + n.length
                             + 4 + e.length);

      publicKey.writeUInt32BE(7, 0, true);
      publicKey.write('ssh-rsa', 4, 7, 'ascii');

      i = 4 + 7;
      publicKey.writeUInt32BE(e.length, i, true);
      e.copy(publicKey, i += 4);

      publicKey.writeUInt32BE(n.length, i += e.length, true);
      n.copy(publicKey, i += 4);
    } else if (keyInfo.type === 'dss') { // DSA
      // prime (p) -- integer
      p = asnReader.readString(Ber.Integer, true);
      if (p === null) {
        errMsg = 'Malformed private key (expected DSA p value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      // group order (q) -- integer
      q = asnReader.readString(Ber.Integer, true);
      if (q === null) {
        errMsg = 'Malformed private key (expected DSA q value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      // group generator (g) -- integer
      g = asnReader.readString(Ber.Integer, true);
      if (g === null) {
        errMsg = 'Malformed private key (expected DSA g value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      // public key value (y) -- integer
      y = asnReader.readString(Ber.Integer, true);
      if (y === null) {
        errMsg = 'Malformed private key (expected DSA y value)';
        if (keyInfo._decrypted)
          errMsg += '. Bad passphrase?';
        throw new Error(errMsg);
      }

      publicKey = new Buffer(4 + 7 // ssh-dss
                             + 4 + p.length
                             + 4 + q.length
                             + 4 + g.length
                             + 4 + y.length);

      publicKey.writeUInt32BE(7, 0, true);
      publicKey.write('ssh-dss', 4, 7, 'ascii');

      i = 4 + 7;
      publicKey.writeUInt32BE(p.length, i, true);
      p.copy(publicKey, i += 4);

      publicKey.writeUInt32BE(q.length, i += p.length, true);
      q.copy(publicKey, i += 4);

      publicKey.writeUInt32BE(g.length, i += q.length, true);
      g.copy(publicKey, i += 4);

      publicKey.writeUInt32BE(y.length, i += g.length, true);
      y.copy(publicKey, i += 4);
    } else { // ECDSA
      d = asnReader.readString(Ber.OctetString, true);
      if (d === null)
        throw new Error('Malformed private key (expected ECDSA private key)');
      asnReader.readByte(); // Skip "complex" context type byte
      var offset = asnReader.readLength(); // Sk ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!ret.encryption) {
  var valid = utils.verifyPPKMAC(ret, undefined, privateKey);
  if (!valid)
    throw new Error('PPK MAC mismatch');
}

// generate a PEM encoded version of the public key
var pubkey = utils.<span class="apidocCodeKeywordSpan">genPublicKey</span>(ret);
ret.public = pubkey.public;
ret.publicOrig = pubkey.publicOrig;

ret.private = privateKey;

// automatically convert private key data to OpenSSL format (including PEM)
// if we don't need to wait for decryption
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.isStreamCipher" id="apidoc.element.ssh2-streams.utils.isStreamCipher">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>isStreamCipher
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStreamCipher(name) {
  return RE_STREAM.test(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.iv_inc" id="apidoc.element.ssh2-streams.utils.iv_inc">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>iv_inc
        <span class="apidocSignatureSpan">(iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iv_inc(iv) {
  var n = 12;
  var c = 0;
  do {
    --n;
    c = iv[n];
    if (c === 255)
      iv[n] = 0;
    else {
      iv[n] = ++c;
      return;
    }
  } while (n &gt; 4);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.parseKey" id="apidoc.element.ssh2-streams.utils.parseKey">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>parseKey
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseKey = function (data) {
  if (Buffer.isBuffer(data))
    data = data.toString('utf8');
  else if (typeof data !== 'string')
    return new Error('Key data must be a Buffer or string');

  var ret = {
    fulltype: undefined,
    type: undefined,
    curve: undefined,
    extra: undefined,
    comment: undefined,
    encryption: undefined,
    private: undefined,
    privateOrig: undefined,
    public: undefined,
    publicOrig: undefined
  };
  var m;
  var i;
  var len;

  data = data.trim().split(/\r\n|\n/);

  while (!data[0].length)
    data.shift();
  while (!data.slice(-1)[0].length)
    data.pop();

  var orig = data.join('\n');

  if ((m = RE_HEADER_OPENSSH_PRIV.exec(data[0]))
      &amp;&amp; RE_FOOTER_OPENSSH_PRIV.test(data.slice(-1))) {
    // OpenSSH private key
    var keyType = m[1].toLowerCase();
    if (keyType === 'dsa')
      keyType = 'dss';

    if (keyType === 'ec' &amp;&amp; semver.lt(process.version, '5.2.0')) {
      return new Error(
        'EC private keys are not supported in this version of node'
      );
    }

    if (!RE_HEADER_OPENSSH.test(data[1])) {
      // unencrypted, no headers
      var privData = new Buffer(data.slice(1, -1).join(''), 'base64');
      if (keyType !== 'ec') {
        ret.fulltype = 'ssh-' + keyType;
      } else {
        // ECDSA
        var asnReader = new Ber.Reader(privData);
        asnReader.readSequence();
        asnReader.readInt();
        asnReader.readString(Ber.OctetString, true);
        asnReader.readByte(); // Skip "complex" context type byte
        var offset = asnReader.readLength(); // Skip context length
        if (offset !== null) {
          asnReader._offset = offset;
          switch (asnReader.readOID()) {
            case '1.2.840.10045.3.1.7':
              // prime256v1/secp256r1
              ret.fulltype = 'ecdsa-sha2-nistp256';
              break;
            case '1.3.132.0.34':
              // secp384r1
              ret.fulltype = 'ecdsa-sha2-nistp384';
              break;
            case '1.3.132.0.35':
              // secp521r1
              ret.fulltype = 'ecdsa-sha2-nistp521';
              break;
          }
        }
        if (ret.fulltype === undefined)
          return new Error('Unsupported EC private key type');
      }
      ret.private = privData;
    } else {
      // possibly encrypted, headers
      for (i = 1, len = data.length; i &lt; len; ++i) {
        m = RE_HEADER_OPENSSH.exec(data[i]);
        if (m) {
          m[1] = m[1].toLowerCase();
          if (m[1] === 'dek-info') {
            m[2] = m[2].split(',');
            ret.encryption = m[2][0].toLowerCase();
            if (m[2].length &gt; 1)
              ret.extra = m[2].slice(1);
          }
        } else if (data[i].length)
          break;
      }
      ret.private = new Buffer(data.slice(i, -1).join(''), 'base64');
    }
    ret.type = keyType;
    ret.privateOrig = new Buffer(orig);
  } else if (m = RE_HEADER_OPENSSH_PUB.exec(data[0])) {
    // OpenSSH public key
    ret.fulltype = m[1];
    ret.type = (m[2] || 'ec').toLowerCase();
    ret.public = new Buffer(m[4], 'base64');
    ret.publicOrig = new Buffer(orig);
    ret.comment = m[5];
    if (m[3]) // ECDSA only
      ret.curve = 'nistp' + m[3];
  } else if (RE_HEADER_RFC4716_PUB.test(data[0])
             &amp;&amp; RE_FOOTER_RFC4716_PUB.test(data.slice(-1))) {
    if (data[1].indexOf(': ') === -1) {
      // no headers
      ret.public = new Buffer(data.slice(1, -1).join(''), 'base64');
    } else {
      // headers
      for (i = 1, len = data.length; i &lt; len; ++i) {
        if (data[i].indexOf(': ') === -1) {
          if (data[i].length)
            break; // start of key data
          else
            continue; // empty line
        }
        while (data[i].substr(-1) === '\\') {
          if (i + 1 &lt; len) {
            data[i] = data[i].slice(0, -1) + data[i + 1];
            data.splice(i + 1, 1);
            --len;
          } else
            return new Error('RFC4716 public key missing header continuation line');
        }
        m = RE_HEADER_RFC4716.exec(data[i]);
        if (m) {
          m[1] = m[1].toLo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* **tcpipForward**(&lt; _string_ &gt;bindAddr, &lt; _integer_ &gt;bindPort[, &lt; _boolean_ &gt;wantReply]) - _boolean_
 - Writes a tcpip forward global request packet. `wantReply` defaults to `true`. Returns `false` if you should wait for the `continue
` event before sending any more traffic.

* **cancelTcpipForward**(&lt; _string_ &gt;bindAddr, &lt; _integer_ &gt;bindPort[, &lt; _boolean_ &gt;wantReply]) -
_boolean_ - Writes a cancel tcpip forward global request packet. `wantReply` defaults to `true`. Returns `false` if you should wait
 for the `continue` event before sending any more traffic.

* **authPassword**(&lt; _string_ &gt;username, &lt; _string_ &gt;password) - _boolean_ - Writes a password userauth request
 packet. Returns `false` if you should wait for the `continue` event before sending any more traffic.

* **authPK**(&lt; _string_ &gt;username, &lt; _object_ &gt;pubKey[, &lt; _function_ &gt;cbSign]) - _boolean_ - Writes
 a publickey userauth request packet. `pubKey` is the object returned from using `utils.<span class="apidocCodeKeywordSpan">parseKey
</span>()` on a private or public key. If `cbSign` is not present, a pubkey check userauth packet is written. Otherwise `cbSign`
is called with `(blob, callback)`, where `blob` is the data to sign with the private key and the resulting signature _Buffer_ is
 passed to `callback` as the first argument. Returns `false` if you should wait for the `continue` event before sending any more
 traffic.

* **authHostbased**(&lt; _string_ &gt;username, &lt; _object_ &gt;pubKey, &lt; _string_ &gt;localHostname, &lt; _string_
 &gt;localUsername, &lt; _function_ &gt;cbSign) - _boolean_ - Writes a hostbased userauth request packet. `pubKey` is the
object returned from using `utils.parseKey()` on a private or public key. `cbSign` is called with `(blob, callback)`, where `blob
` is the data to sign with the private key and the resulting signature _Buffer_ is passed to `callback` as the first argument. Returns
 `false` if you should wait for the `continue` event before sending any more traffic.

* **authKeyboard**(&lt; _string_ &gt;username) - _boolean_ - Writes a keyboard-interactive userauth request packet. Returns `
false` if you should wait for the `continue` event before sending any more traffic.

* **authNone**(&lt; _string_ &gt;username) - _boolean_ - Writes a "none" userauth request packet. Returns `false`
if you should wait for the `continue` event before sending any more traffic.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.readInt" id="apidoc.element.ssh2-streams.utils.readInt">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>readInt
        <span class="apidocSignatureSpan">(buffer, start, stream, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInt(buffer, start, stream, cb) {
  var bufferLen = buffer.length;
  if (start &lt; 0 || start &gt;= bufferLen || (bufferLen - start) &lt; 4) {
    stream &amp;&amp; stream._cleanup(cb);
    return false;
  }

  return buffer.readUInt32BE(start, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var privData = new Buffer(data.slice(1, -1).join(''), 'base64');
if (keyType !== 'ec') {
  ret.fulltype = 'ssh-' + keyType;
} else {
  // ECDSA
  var asnReader = new Ber.Reader(privData);
  asnReader.readSequence();
  asnReader.<span class="apidocCodeKeywordSpan">readInt</span>();
  asnReader.readString(Ber.OctetString, true);
  asnReader.readByte(); // Skip "complex" context type byte
  var offset = asnReader.readLength(); // Skip context length
  if (offset !== null) {
    asnReader._offset = offset;
    switch (asnReader.readOID()) {
      case '1.2.840.10045.3.1.7':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.readString" id="apidoc.element.ssh2-streams.utils.readString">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>readString
        <span class="apidocSignatureSpan">(buffer, start, encoding, stream, cb, maxLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readString(buffer, start, encoding, stream, cb, maxLen) {
  if (encoding &amp;&amp; !Buffer.isBuffer(encoding) &amp;&amp; typeof encoding !== 'string') {
    if (typeof cb === 'number')
      maxLen = cb;
    cb = stream;
    stream = encoding;
    encoding = undefined;
  }

  start || (start = 0);
  var bufferLen = buffer.length;
  var left = (bufferLen - start);
  var len;
  var end;
  if (start &lt; 0 || start &gt;= bufferLen || left &lt; 4) {
    stream &amp;&amp; stream._cleanup(cb);
    return false;
  }

  len = buffer.readUInt32BE(start, true);
  if (len &gt; (maxLen || MAX_STRING_LEN) || left &lt; (4 + len)) {
    stream &amp;&amp; stream._cleanup(cb);
    return false;
  }

  start += 4;
  end = start + len;
  buffer._pos = end;

  if (encoding) {
    if (Buffer.isBuffer(encoding)) {
      buffer.copy(encoding, 0, start, end);
      return encoding;
    } else
      return buffer.toString(encoding, start, end);
  } else
    return buffer.slice(start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (keyType !== 'ec') {
  ret.fulltype = 'ssh-' + keyType;
} else {
  // ECDSA
  var asnReader = new Ber.Reader(privData);
  asnReader.readSequence();
  asnReader.readInt();
  asnReader.<span class="apidocCodeKeywordSpan">readString</span>(Ber.OctetString, true);
  asnReader.readByte(); // Skip "complex" context type byte
  var offset = asnReader.readLength(); // Skip context length
  if (offset !== null) {
    asnReader._offset = offset;
    switch (asnReader.readOID()) {
      case '1.2.840.10045.3.1.7':
        // prime256v1/secp256r1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ssh2-streams.utils.verifyPPKMAC" id="apidoc.element.ssh2-streams.utils.verifyPPKMAC">
        function <span class="apidocSignatureSpan">ssh2-streams.utils.</span>verifyPPKMAC
        <span class="apidocSignatureSpan">(keyInfo, passphrase, privateKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verifyPPKMAC(keyInfo, passphrase, privateKey) {
  if (keyInfo._macresult !== undefined)
    return keyInfo._macresult;
  else if (!keyInfo.ppk)
    throw new Error("Key isn't a PPK");
  else if (!keyInfo.privateMAC)
    throw new Error('Missing MAC');
  else if (!privateKey)
    throw new Error('Missing raw private key data');
  else if (keyInfo.encryption &amp;&amp; typeof passphrase !== 'string')
    throw new Error('Missing passphrase for encrypted PPK');
  else if (keyInfo.encryption &amp;&amp; !keyInfo._decrypted)
    throw new Error('PPK must be decrypted before verifying MAC');

  var mac = keyInfo.privateMAC;
  var typelen = keyInfo.fulltype.length;
  // encryption algorithm is converted at this point for use with OpenSSL,
  // so we need to use the original value so that the MAC is calculated
  // correctly
  var enc = (keyInfo.encryption ? 'aes256-cbc' : 'none');
  var enclen = enc.length;
  var commlen = Buffer.byteLength(keyInfo.comment);
  var pub = keyInfo.public;
  var publen = pub.length;
  var privlen = privateKey.length;
  var macdata = new Buffer(4 + typelen
                           + 4 + enclen
                           + 4 + commlen
                           + 4 + publen
                           + 4 + privlen);
  var p = 0;

  macdata.writeUInt32BE(typelen, p, true);
  macdata.write(keyInfo.fulltype, p += 4, typelen, 'ascii');
  macdata.writeUInt32BE(enclen, p += typelen, true);
  macdata.write(enc, p += 4, enclen, 'ascii');
  macdata.writeUInt32BE(commlen, p += enclen, true);
  macdata.write(keyInfo.comment, p += 4, commlen, 'utf8');
  macdata.writeUInt32BE(publen, p += commlen, true);
  pub.copy(macdata, p += 4);
  macdata.writeUInt32BE(privlen, p += publen, true);
  privateKey.copy(macdata, p += 4);

  if (typeof passphrase !== 'string')
    passphrase = '';

  var mackey = crypto.createHash('sha1')
                     .update('putty-private-key-file-mac-key', 'ascii')
                     .update(passphrase, 'utf8')
                     .digest();

  var calcMAC = crypto.createHmac('sha1', mackey)
                      .update(macdata)
                      .digest('hex');

  return (keyInfo._macresult = (calcMAC === mac));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var privateKey = new Buffer(m[5].replace(/\r?\n/g, ''), 'base64');

ret.privateMAC = m[6].replace(/\r?\n/g, '');

// automatically verify private key MAC if we don't need to wait for
// decryption
if (!ret.encryption) {
  var valid = utils.<span class="apidocCodeKeywordSpan">verifyPPKMAC</span>(ret, undefined, privateKey);
  if (!valid)
    throw new Error('PPK MAC mismatch');
}

// generate a PEM encoded version of the public key
var pubkey = utils.genPublicKey(ret);
ret.public = pubkey.public;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>